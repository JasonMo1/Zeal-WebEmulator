{"version":3,"file":"jsstore.worker.min.js","mappings":"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","sources":["webpack://JsStoreWorker/webpack/bootstrap","webpack://JsStoreWorker/webpack/runtime/define property getters","webpack://JsStoreWorker/webpack/runtime/hasOwnProperty shorthand","webpack://JsStoreWorker/webpack/runtime/make namespace object","webpack://JsStoreWorker/./src/common/utils/promise_resolve.ts","webpack://JsStoreWorker/./src/common/enums.ts","webpack://JsStoreWorker/./src/common/utils/promise.ts","webpack://JsStoreWorker/./src/worker/model/table_meta.ts","webpack://JsStoreWorker/./src/worker/meta_helper.ts","webpack://JsStoreWorker/./src/worker/model/db_meta.ts","webpack://JsStoreWorker/./src/common/utils/for_obj.ts","webpack://JsStoreWorker/./src/worker/utils/log_helper.ts","webpack://JsStoreWorker/./src/worker/idbutil/index.ts","webpack://JsStoreWorker/./src/common/utils/promise_all.ts","webpack://JsStoreWorker/./src/worker/utils/promise_reject.ts","webpack://JsStoreWorker/./src/worker/utils/get_error.ts","webpack://JsStoreWorker/./src/worker/executors/base.ts","webpack://JsStoreWorker/./src/worker/utils/get_error_from_exception.ts","webpack://JsStoreWorker/./src/worker/utils/get_data_type.ts","webpack://JsStoreWorker/./src/worker/utils/is_null.ts","webpack://JsStoreWorker/./src/worker/executors/insert/values_checker.ts","webpack://JsStoreWorker/./src/worker/executors/update/schema_checker.ts","webpack://JsStoreWorker/./src/worker/executors/query_helper.ts","webpack://JsStoreWorker/./src/worker/executors/insert/index.ts","webpack://JsStoreWorker/./src/worker/constants/index.ts","webpack://JsStoreWorker/./src/worker/utils/set_cross_browser_idb.ts","webpack://JsStoreWorker/./src/worker/utils/is_array.ts","webpack://JsStoreWorker/./src/worker/utils/get_keys.ts","webpack://JsStoreWorker/./src/worker/utils/get_length.ts","webpack://JsStoreWorker/./src/worker/utils/get_object_first_key.ts","webpack://JsStoreWorker/./src/worker/executors/select/then_evaluator.ts","webpack://JsStoreWorker/./src/worker/executors/select/where.ts","webpack://JsStoreWorker/./src/worker/executors/select/not_where.ts","webpack://JsStoreWorker/./src/worker/utils/remove_space.ts","webpack://JsStoreWorker/./src/worker/executors/select/order_by.ts","webpack://JsStoreWorker/./src/worker/utils/get_regex_from_like.ts","webpack://JsStoreWorker/./src/worker/utils/clone.ts","webpack://JsStoreWorker/./src/worker/utils/compare.ts","webpack://JsStoreWorker/./src/worker/executors/where_checker.ts","webpack://JsStoreWorker/./src/worker/executors/base_fetch.ts","webpack://JsStoreWorker/./src/worker/executors/select/regex.ts","webpack://JsStoreWorker/./src/worker/executors/select/join.ts","webpack://JsStoreWorker/./src/worker/memory_store/index.ts","webpack://JsStoreWorker/./src/worker/executors/select/index.ts","webpack://JsStoreWorker/./src/worker/utils/is_object.ts","webpack://JsStoreWorker/./src/worker/executors/select/in.ts","webpack://JsStoreWorker/./src/worker/executors/select/base_select.ts","webpack://JsStoreWorker/./src/worker/executors/select/group_by.ts","webpack://JsStoreWorker/./src/worker/executors/count/not_where.ts","webpack://JsStoreWorker/./src/worker/executors/count/where.ts","webpack://JsStoreWorker/./src/worker/executors/count/index.ts","webpack://JsStoreWorker/./src/worker/executors/count/regex.ts","webpack://JsStoreWorker/./src/worker/executors/count/in.ts","webpack://JsStoreWorker/./src/worker/utils/resolve.ts","webpack://JsStoreWorker/./src/worker/executors/update/update_value.ts","webpack://JsStoreWorker/./src/worker/executors/update/index.ts","webpack://JsStoreWorker/./src/worker/executors/update/not_where.ts","webpack://JsStoreWorker/./src/worker/executors/update/where.ts","webpack://JsStoreWorker/./src/worker/executors/update/regex.ts","webpack://JsStoreWorker/./src/worker/executors/update/in.ts","webpack://JsStoreWorker/./src/worker/intersect/index.ts","webpack://JsStoreWorker/./src/worker/executors/drop_db.ts","webpack://JsStoreWorker/./src/worker/union/index.ts","webpack://JsStoreWorker/./src/worker/executors/remove/where.ts","webpack://JsStoreWorker/./src/worker/executors/remove/index.ts","webpack://JsStoreWorker/./src/worker/executors/remove/in.ts","webpack://JsStoreWorker/./src/worker/executors/remove/not_where.ts","webpack://JsStoreWorker/./src/worker/executors/remove/regex.ts","webpack://JsStoreWorker/./src/worker/executors/clear/index.ts","webpack://JsStoreWorker/./src/worker/executors/transaction/index.ts","webpack://JsStoreWorker/./src/worker/utils/db_schema.ts","webpack://JsStoreWorker/./src/worker/query_manager.ts","webpack://JsStoreWorker/./src/worker/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const promiseResolve = (value?) => {\n    return Promise.resolve(value);\n}","import { IErrorType } from \"./interfaces\";\n\nexport const ERROR_TYPE = {\n    InvalidUpdateColumn: \"invalid_update_column\",\n    UndefinedColumn: \"undefined_column\",\n    UndefinedValue: \"undefined_value\",\n    UndefinedColumnName: \"undefined_column_name\",\n    UndefinedDbName: \"undefined_database_name\",\n    UndefinedColumnValue: \"undefined_column_value\",\n    NotArray: \"not_array\",\n    NoValueSupplied: \"no_value_supplied\",\n    ColumnNotExist: \"column_not_exist\",\n    NoIndexFound: \"no_index_found\",\n    InvalidOp: \"invalid_operator\",\n    NullValue: \"null_value\",\n    WrongDataType: \"wrong_data_type\",\n    TableNotExist: \"table_not_exist\",\n    DbNotExist: \"db_not_exist\",\n    ConnectionAborted: \"connection_aborted\",\n    ConnectionClosed: \"connection_closed\",\n    NotObject: \"not_object\",\n    InvalidConfig: \"invalid_config\",\n    DbBlocked: \"Db_blocked\",\n    IndexedDbNotSupported: \"indexeddb_not_supported\",\n    NullValueInWhere: \"null_value_in_where\",\n    InvalidJoinQuery: 'invalid_join_query',\n    InvalidQuery: 'invalid_query',\n    ImportScriptsFailed: 'import_scripts_failed',\n    MethodNotExist: 'method_not_exist',\n    Unknown: \"unknown\",\n    InvalidMiddleware: \"invalid_middleware\"\n} as IErrorType;\n\nif (process.env.NODE_ENV !== 'production') {\n    Object.assign(ERROR_TYPE, {\n        InvalidOrderQuery: 'invalid_order_query',\n        InvalidGroupQuery: 'invalid_group_query'\n    });\n}\n\nexport enum WORKER_STATUS {\n    Registered = \"registerd\",\n    Failed = \"failed\",\n    NotStarted = \"not_started\"\n}\n\nexport enum DATA_TYPE {\n    String = \"string\",\n    Object = \"object\",\n    Array = \"array\",\n    Number = \"number\",\n    Boolean = \"boolean\",\n    Null = \"null\",\n    DateTime = \"date_time\"\n}\n\nexport enum API {\n    InitDb = \"init_db\",\n    Get = \"get\",\n    Set = \"set\",\n    Select = \"select\",\n    Insert = \"insert\",\n    Update = \"update\",\n    Remove = \"remove\",\n    OpenDb = \"open_db\",\n    Clear = \"clear\",\n    DropDb = \"drop_db\",\n    Count = \"count\",\n    ChangeLogStatus = \"change_log_status\",\n    Terminate = \"terminate\",\n    Transaction = \"transaction\",\n    CloseDb = \"close_db\",\n    Union = \"union\",\n    Intersect = \"intersect\",\n    ImportScripts = \"import_scripts\",\n    Middleware = \"middleware\"\n}\n\nexport enum EVENT {\n    RequestQueueEmpty = \"requestQueueEmpty\",\n    RequestQueueFilled = \"requestQueueFilled\",\n    Upgrade = \"upgrade\",\n    Create = \"create\",\n    Open = \"open\"\n}\n\nexport enum QUERY_OPTION {\n    Where = \"where\",\n    Like = 'like',\n    Regex = 'regex',\n    In = 'in',\n    Equal = \"=\",\n    Between = '-',\n    GreaterThan = '>',\n    LessThan = '<',\n    GreaterThanEqualTo = \">=\",\n    LessThanEqualTo = \"<=\",\n    NotEqualTo = \"!=\",\n    Aggregate = \"aggregate\",\n    Max = \"max\",\n    Min = \"min\",\n    Avg = \"avg\",\n    Count = \"count\",\n    Sum = \"sum\",\n    List = \"list\",\n    Or = \"or\",\n    Skip = \"skip\",\n    Limit = \"limit\",\n    And = \"and\",\n    IgnoreCase = \"ignoreCase\",\n    Then = \"then\"\n}\n\nexport enum IDB_MODE {\n    ReadOnly = \"readonly\",\n    ReadWrite = \"readwrite\"\n}\n\nexport enum OCCURENCE {\n    First = 'f',\n    Last = 'l',\n    Any = 'a'\n}\n\nexport enum CONNECTION_STATUS {\n    Connected = \"connected\",\n    Closed = \"closed\",\n    NotStarted = \"not_started\",\n    UnableToStart = \"unable_to_start\",\n    ClosedByJsStore = \"closed_by_jsstore\"\n}","export const promise = <T>(cb: (res, rej?) => any) => {\n    return new Promise<T>(cb);\n}","import { ITable, IAlterQuery, IColumn, TColumns } from \"@/common\";\n\nexport class TableMeta {\n    name: string;\n    columns: IColumn[] = [];\n    primaryKey: string;\n    autoIncColumnValue = {};\n    alter?: IAlterQuery;\n\n    constructor(table: ITable) {\n        this.columns = this.setColumn(table.columns);\n        this.name = table.name;\n        this.alter = table.alter || {};\n    }\n\n    setColumn(tableColumns: TColumns) {\n        const columns = [];\n        for (const columnName in tableColumns) {\n            const column: IColumn = tableColumns[columnName] as any;\n            column.name = columnName;\n            if (column.autoIncrement) {\n                this.autoIncColumnValue[columnName] = 0;\n            }\n            if (column.primaryKey) {\n                this.primaryKey = columnName;\n            }\n            column.enableSearch = column.enableSearch == null ? true : column.enableSearch;\n            const existingColumnIndex = this.columns.indexOf(q => q.name === columnName);\n            if (existingColumnIndex < 0) {\n                columns.push(column);\n            }\n            else {\n                const existingColumn = this.columns[existingColumnIndex];\n                Object.assign(existingColumn, column);\n            }\n        }\n        return columns;\n    }\n\n\n}","import { IDBUtil } from \"@/worker/idbutil\";\nimport { promise } from \"@/common\";\n\nexport class MetaHelper {\n    static tableName = \"JsStore_Meta\";\n    static autoIncrementKey(tableName: string, columnName: string) {\n        return `JsStore_${tableName}_${columnName}_Value`;\n    }\n    static dbSchema = `JsStore_DbSchema`;\n\n    static set(key, value, util: IDBUtil) {\n        if (!util.tx) {\n            util.createTransaction([MetaHelper.tableName]);\n        }\n        const store = util.objectStore(MetaHelper.tableName);\n\n        return promise((res, rej) => {\n            const req = store.put({\n                key, value\n            });\n            req.onsuccess = () => {\n                res();\n            };\n            req.onerror = rej;\n        });\n    }\n\n    static get(key, util: IDBUtil) {\n        if (!util.tx) {\n            util.createTransaction([MetaHelper.tableName]);\n        }\n        const store = util.objectStore(MetaHelper.tableName);\n\n        return promise((res, rej) => {\n            const req = store.get(\n                util.keyRange(key)\n            );\n            req.onsuccess = () => {\n                const result = req.result;\n                res(result && result.value);\n            };\n            req.onerror = rej;\n        });\n    }\n\n    static remove(key, util: IDBUtil) {\n        if (!util.tx) {\n            util.createTransaction([MetaHelper.tableName]);\n        }\n        const store = util.objectStore(MetaHelper.tableName);\n\n        return promise((res, rej) => {\n            const req = store.delete(\n                util.keyRange(key)\n            );\n            req.onsuccess = res;\n            req.onerror = rej;\n        });\n    }\n}","import { IDataBase } from \"@/common\";\nimport { TableMeta } from \"./table_meta\";\nimport { MetaHelper } from \"@worker/meta_helper\";\n\nexport class DbMeta {\n    name: string;\n    version: number;\n    tables: TableMeta[];\n\n    constructor(db: IDataBase) {\n        this.name = db.name;\n        this.version = db.version || 1;\n        db.tables.push({\n            name: MetaHelper.tableName,\n            columns: {\n                key: {\n                    primaryKey: true\n                },\n                value: {\n                    enableSearch: false\n                }\n            },\n        })\n        this.tables = db.tables.map(table => {\n            return new TableMeta(table);\n        });\n    }\n}","export const forObj = (obj: object, cb: (key, value) => void) => {\n    for (const key in obj) {\n        cb(key, obj[key]);\n    }\n}","import { ERROR_TYPE, IError } from \"@/common\";\n\nexport class LogHelper implements IError {\n    type: string;\n    message: string;\n    private info_: any;\n\n    status: boolean;\n\n    log(msg) {\n        if (this.status) {\n            console.log(msg);\n        }\n    }\n\n    constructor(type: string, info?) {\n        this.type = type;\n        this.info_ = info;\n        this.message = this.getMsg_();\n    }\n\n    throw() {\n        throw this.get();\n    }\n\n\n    logError() {\n        console.error(this.get());\n    }\n\n\n\n    get() {\n        return {\n            message: this.message,\n            type: this.type\n        } as IError;\n    }\n\n    private getMsg_() {\n        let errMsg: string;\n        const info = this.info_;\n        const errorHandler = {\n            [ERROR_TYPE.NotArray]() {\n                errMsg = \"Supplied value is not an array\";\n            },\n            [ERROR_TYPE.UndefinedColumn]() {\n                errMsg = \"Column is undefined in Where\";\n            },\n            [ERROR_TYPE.UndefinedValue]() {\n                errMsg = \"Value is undefined in Where\";\n            },\n            [ERROR_TYPE.UndefinedColumnName]() {\n                errMsg = \"Column name is undefined '\" + info['TableName'] + \"'\";\n            },\n            [ERROR_TYPE.UndefinedDbName]() {\n                errMsg = \"Database name is not supplied\";\n            },\n            [ERROR_TYPE.UndefinedColumnValue]() {\n                errMsg = \"Column value is undefined\";\n            },\n            [ERROR_TYPE.NoValueSupplied]() {\n                errMsg = \"No value is supplied\";\n            },\n            [ERROR_TYPE.InvalidOp]() {\n                errMsg = \"Invalid Op Value '\" + info['Op'] + \"'\";\n            },\n            [ERROR_TYPE.ColumnNotExist]() {\n                const column = info['column'];\n                errMsg = info['isOrder'] ?\n                    (\n                        process.env.NODE_ENV !== 'production' && info.isJoin ?\n                            `Column '${column}' in order query is invalid. Please use '<table>.<column>' format for specifying a column in join query.` :\n                            `Column '${column}' in order query does not exist`\n                    ) :\n                    `Column '${column}' does not exist`;\n            },\n            [ERROR_TYPE.NoIndexFound]() {\n                errMsg = \"No index found for column '\" + info['column'] + \"'. Query can not be executed without index.\";\n            },\n            [ERROR_TYPE.NullValue]() {\n                errMsg = \"Null value is not allowed for column '\" + info['ColumnName'] + \"'\";\n            },\n            [ERROR_TYPE.WrongDataType]() {\n                errMsg = \"Supplied value for column '\" + info['column'] +\n                    \"' have wrong data type\";\n            },\n            [ERROR_TYPE.TableNotExist]() {\n                errMsg = \"Table '\" + info['tableName'] + \"' does not exist\";\n            },\n            [ERROR_TYPE.DbNotExist]() {\n                errMsg = `Database with name ${info['dbName']} does not exist`;\n            },\n            [ERROR_TYPE.NotObject]() {\n                errMsg = \"supplied value is not object\";\n            },\n            [ERROR_TYPE.InvalidOp]() {\n                errMsg = \"Invalid Config '\" + info['Config'] + \" '\";\n            },\n            [ERROR_TYPE.DbBlocked]() {\n                errMsg = `database is blocked, cant be deleted right now`;\n            },\n            [ERROR_TYPE.NullValueInWhere]() {\n                errMsg = `Null/undefined is not allowed in where. Column '${info['column']}' has null`;\n            },\n            [ERROR_TYPE.MethodNotExist]() {\n                errMsg = `method '${info}' does not exist.`;\n            },\n            [ERROR_TYPE.IndexedDbNotSupported]() {\n                errMsg = \"Browser does not support indexeddb\";\n            },\n            getInfo() {\n                errMsg = info;\n            },\n            [ERROR_TYPE.InvalidJoinQuery]() {\n                errorHandler.getInfo();\n            },\n            [ERROR_TYPE.ImportScriptsFailed]() {\n                errorHandler.getInfo();\n            },\n            [ERROR_TYPE.InvalidMiddleware]() {\n                errMsg = `No function ${info} is found.`;\n            },\n        };\n        if (process.env.NODE_ENV !== 'production') {\n            Object.assign(errorHandler, {\n                [ERROR_TYPE.InvalidOrderQuery]() {\n                    errorHandler.getInfo();\n                },\n                [ERROR_TYPE.InvalidGroupQuery]() {\n                    errorHandler.getInfo();\n                },\n            })\n        }\n        const errorType = this.type;\n        const method = errorHandler[errorType];\n        if (method) {\n            method();\n        }\n        else {\n            if (!errorType) {\n                this.type = ERROR_TYPE.Unknown\n            }\n            errMsg = this.message;\n        }\n        return errMsg;\n    }\n}","import { DbMeta, TableMeta } from \"@worker/model\";\nimport { IDB_MODE, QUERY_OPTION, promise, forObj, IColumn, IDataBase, InitDbResult } from \"@/common\";\nimport { LogHelper, userDbSchema } from \"@worker/utils\";\nimport { MetaHelper } from \"../meta_helper\";\n\n\nexport class IDBUtil {\n\n    db: DbMeta;\n\n    con: IDBDatabase;\n    tx: IDBTransaction;\n\n    logger = new LogHelper(null);\n\n    emptyTx() {\n        if (!this.tx) return;\n        this.tx.oncomplete = null;\n        this.tx.onabort = null;\n        this.tx.onerror = null;\n        this.tx = null;\n    }\n\n    createTransactionIfNotExist(tables: string[], mode?: IDB_MODE) {\n        if (!this.tx) {\n            this.createTransaction(tables, mode);\n        }\n    }\n\n    createTransaction(tables: string[], mode = IDB_MODE.ReadWrite) {\n        this.tx = this.con.transaction(tables, mode);\n        return promise((res, rej) => {\n            this.tx.oncomplete = res;\n            this.tx.onabort = res;\n            this.tx.onerror = rej;\n        });\n    }\n\n    keyRange(value, op?) {\n        let keyRange: IDBKeyRange;\n        switch (op) {\n            case QUERY_OPTION.Between: keyRange = IDBKeyRange.bound(value.low, value.high, false, false); break;\n            case QUERY_OPTION.GreaterThan: keyRange = IDBKeyRange.lowerBound(value, true); break;\n            case QUERY_OPTION.GreaterThanEqualTo: keyRange = IDBKeyRange.lowerBound(value); break;\n            case QUERY_OPTION.LessThan: keyRange = IDBKeyRange.upperBound(value, true); break;\n            case QUERY_OPTION.LessThanEqualTo: keyRange = IDBKeyRange.upperBound(value); break;\n            default: keyRange = IDBKeyRange.only(value); break;\n        }\n        return keyRange;\n    }\n\n    objectStore(name: string) {\n        return this.tx.objectStore(name);\n    }\n\n    abortTransaction() {\n        if (this.tx) {\n            this.tx.abort();\n        }\n    }\n\n    close() {\n        if (this.con) {\n            this.con.close();\n        }\n        // wait for 100 ms before success\n        return promise(res => {\n            this.con = null;\n            setTimeout(res, 100);\n        });\n    }\n\n    initDb(db: DbMeta) {\n        let isDbCreated = false;\n        const dbVersion = db.version;\n        let oldVersion;\n        const initLogic = (res, rej) => {\n            const dbOpenRequest = indexedDB.open(db.name, dbVersion);\n            dbOpenRequest.onsuccess = () => {\n                this.con = dbOpenRequest.result;\n                this.con.onversionchange = (e: any) => {\n                    // if (e.newVersion === null) { // An attempt is made to delete the db\n                    e.target.close(); // Manually close our connection to the db\n                    // }\n                }\n\n                res({\n                    isCreated: isDbCreated,\n                    oldVersion: oldVersion,\n                    newVersion: dbVersion\n                } as InitDbResult);\n            }\n\n            dbOpenRequest.onerror = (e) => {\n                console.error(\"error\", e);\n                rej(e);\n            };\n\n            dbOpenRequest.onupgradeneeded = (e: IDBVersionChangeEvent) => {\n                oldVersion = e.oldVersion;\n                const target: {\n                    result: IDBDatabase,\n                    transaction: IDBTransaction\n                } = (e as any).target\n                const upgradeConnection = target.result;\n                isDbCreated = true;\n                const transaction = target.transaction;\n                const storeNames = upgradeConnection.objectStoreNames;\n                const createObjectStore = (table: TableMeta) => {\n                    const option: IDBObjectStoreParameters = table.primaryKey ? {\n                        keyPath: table.primaryKey\n                    } : {\n                            autoIncrement: true\n                        }\n\n                    const store = upgradeConnection.createObjectStore(table.name, option);\n                    table.columns.forEach(column => {\n                        addColumn(store, column)\n                    });\n                }\n                const addColumn = (store: IDBObjectStore, column: IColumn) => {\n                    const columnName = column.name;\n                    if (column.enableSearch && !store.indexNames.contains(columnName)) {\n                        const options = column.primaryKey ? { unique: true } : { unique: column.unique };\n                        options['multiEntry'] = column.multiEntry;\n                        const keyPath = column.keyPath == null ? columnName : column.keyPath;\n                        store.createIndex(columnName, keyPath, options);\n                    }\n                }\n                const deleteColumn = (store: IDBObjectStore, table: TableMeta, columnName: string) => {\n                    const index = table.columns.findIndex(q => q.name === columnName);\n                    if (index >= 0) {\n                        table.columns.splice(index, 1);\n                        store.deleteIndex(columnName);\n                    }\n                }\n                db.tables.forEach(table => {\n                    if (!storeNames.contains(table.name)) {\n                        return createObjectStore(table);\n                    }\n                    const store = transaction.objectStore(table.name);\n                    for (let i = oldVersion + 1; i <= dbVersion; i++) {\n                        const alterQuery = table.alter[i];\n                        if (alterQuery) {\n                            if (alterQuery.add) {\n                                const newColumns = table.setColumn(alterQuery.add);\n                                newColumns.forEach(column => {\n                                    addColumn(store, column);\n                                    table.columns.push(column);\n                                })\n                            }\n                            forObj(\n                                alterQuery.drop || {}, ((columnName) => {\n                                    deleteColumn(store, table, columnName);\n                                })\n                            )\n                            forObj(\n                                alterQuery.modify || {}, ((columnName, column: IColumn) => {\n                                    const shouldDelete = column.multiEntry || column.keyPath || column.unique;\n                                    let targetColumn = table.columns.find(q => q.name === columnName);\n                                    const newColumn = Object.assign(targetColumn, column);\n                                    newColumn.name = columnName;\n                                    if (shouldDelete) {\n                                        deleteColumn(store, table, columnName);\n                                        addColumn(store, newColumn);\n                                        table.columns.push(newColumn);\n                                    }\n                                })\n                            )\n                        }\n                    }\n                });\n\n                for (let i = 0, length = storeNames.length; i < length; i++) {\n                    const storeName = storeNames.item(i);\n                    const tableIndex = db.tables.findIndex(qry => qry.name === storeName);\n                    if (tableIndex < 0) {\n                        upgradeConnection.deleteObjectStore(storeName);\n                    }\n                }\n\n            }\n        }\n        return promise<InitDbResult>(initLogic)\n    }\n}","export const promiseAll = <T>(promises: any) => {\n    return Promise.all<T>(promises);\n};","export const promiseReject = (value) => {\n    return Promise.reject(value);\n}","import { LogHelper } from \"./log_helper\";\n\nexport const getError = (e) => {\n    const customError = e instanceof LogHelper;\n    if (customError) {\n        e.logError();\n        return (e as LogHelper).get();\n    }\n    else {\n        let error;\n        if (e.name) {\n            error = new LogHelper(e.name);\n            error.message = e.message;\n        }\n        else {\n            error = new LogHelper((e as any).target.error.name);\n            error.message = (e as any).target.error.message;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            error.logError();\n        }\n        return error.get();\n    }\n}","import { IDBUtil } from \"@worker/idbutil\";\nimport { IInsertQuery, ISelectQuery, IUpdateQuery } from \"@/common\";\nimport { promiseReject, getErrorFromException } from \"@worker/utils\";\n\nexport class Base {\n\n    get db() {\n        return this.util.db;\n    }\n\n    util: IDBUtil;\n    query: IInsertQuery | ISelectQuery | IUpdateQuery;\n\n    rowAffected = 0;\n    isTxQuery = false;\n    objectStore: IDBObjectStore;\n    tableName: string;\n\n    protected results: any[] = [];\n\n    table(name?: string) {\n        const tableName = name || this.tableName;\n        return this.db.tables.find(q => q.name === tableName)\n    }\n\n    primaryKey(tableName?: string) {\n        const query = this.query as ISelectQuery;\n        if (!query.from && query.store && query.meta) {\n            const primaryKey = query.meta.primaryKey;\n            if (process.env.NODE_ENV !== 'production') {\n                if (primaryKey == null) {\n                    delete query.store;\n                    console.warn(`no primary key found for query - ${JSON.stringify(this.query)}`);\n                }\n            }\n            return primaryKey;\n        }\n        const table = this.table(tableName);\n        if (process.env.NODE_ENV !== 'production') {\n            if (table == null && query.store) {\n                delete query.store;\n                const metaValue = query.meta;\n                if (!metaValue || !metaValue.primaryKey) {\n                    console.warn(`no primary key found for query - ${JSON.stringify(this.query)}. Please supply primary key in meta field.`);\n                }\n            }\n        }\n        return table.primaryKey;\n    }\n\n\n    protected getColumnInfo(columnName: string, tableName?: string) {\n        return this.table(tableName).columns.find(column => column.name === columnName);\n    }\n\n\n\n    onException(ex: DOMException, type?) {\n        console.error(ex);\n        this.util.abortTransaction();\n        return promiseReject(\n            getErrorFromException(ex, type)\n        );\n    }\n}","import { ERROR_TYPE } from \"@/common\"\nimport { getError } from \"./get_error\";\n\nexport const getErrorFromException = (ex, type = ERROR_TYPE.InvalidQuery) => {\n    ex.name = type;\n    return getError(ex);\n}","import { DATA_TYPE } from \"@/common\";\n\nexport const getDataType = (value) => {\n    if (value == null) {\n        return DATA_TYPE.Null;\n    }\n    const type = typeof value;\n    switch (type) {\n        case 'object':\n            if (Array.isArray(value)) {\n                return DATA_TYPE.Array;\n            }\n            if (value instanceof Date) {\n                return DATA_TYPE.DateTime;\n            }\n    }\n    return type;\n}","export const isNull = (value) => {\n    if (value == null) {\n        return true;\n    } else {\n        switch (typeof value) {\n            // case 'string': return value.length === 0;\n            case 'number': return isNaN(value);\n        }\n    }\n    return false;\n};","import { TableMeta } from \"@/worker/model/table_meta\";\nimport { IColumn, TStringAny, ERROR_TYPE, DATA_TYPE, IInsertQuery } from \"@/common\";\nimport { getDataType, LogHelper, isNull } from \"@/worker/utils\";\n\n\nexport class ValuesChecker {\n    table: TableMeta;\n    autoIncrementValue;\n    query: IInsertQuery;\n\n    constructor(table: TableMeta, autoIncValues) {\n        this.table = table;\n        this.autoIncrementValue = autoIncValues;\n    }\n\n    checkAndModifyValues(query: IInsertQuery) {\n        let err: LogHelper;\n        this.query = query;\n        const values = query.values;\n        const ignoreIndexes = [];\n        values.every((item, index) => {\n            err = this.checkAndModifyValue(item);\n            if (query.ignore && err) {\n                ignoreIndexes.push(index);\n                err = null;\n            }\n            return err ? false : true;\n        });\n        ignoreIndexes.forEach(index => {\n            values.splice(index, 1);\n        });\n        return { err, values };\n    }\n\n    private checkAndModifyValue(value) {\n        let error: LogHelper;\n        this.table.columns.every(column => {\n            error = this.checkAndModifyColumnValue_(column, value);\n            return error ? false : true;\n        })\n        return error;\n    }\n\n    private checkNotNullAndDataType_(column: IColumn, value: TStringAny) {\n        // check not null schema\n        if (column.notNull && isNull(value[column.name])) {\n            return this.getError(ERROR_TYPE.NullValue, { ColumnName: column.name });\n        }\n        // check datatype\n        else if (column.dataType && !isNull(value[column.name]) &&\n            getDataType(value[column.name]) !== column.dataType) {\n            return this.getError(ERROR_TYPE.WrongDataType, { column: column.name });\n        }\n    }\n\n    private checkAndModifyColumnValue_(column: IColumn, value: TStringAny) {\n        const columnValue = value[column.name];\n        // check auto increment scheme\n        if (column.autoIncrement) {\n            // if value is null, then create the autoincrement value\n            if (isNull(columnValue)) {\n                value[column.name] = ++this.autoIncrementValue[column.name];\n            }\n            else {\n                if (getDataType(columnValue) === DATA_TYPE.Number) {\n                    // if column value is greater than autoincrement value saved, then make the\n                    // column value as autoIncrement value\n                    if (columnValue > this.autoIncrementValue[column.name]) {\n                        this.autoIncrementValue[column.name] = columnValue;\n                    }\n                }\n            }\n        }\n        // check Default Schema\n        else if (column.default !== undefined && isNull(columnValue)) {\n            value[column.name] = column.default;\n        }\n        const query = this.query;\n        if (query.validation) {\n            return this.checkNotNullAndDataType_(column, value);\n        }\n    }\n\n    private getError(error: string, details: object) {\n        return new LogHelper(error, details);\n    }\n}","import { IColumn, DATA_TYPE, ERROR_TYPE } from \"@/common\";\nimport { LogHelper, isNull, getDataType } from \"@worker/utils\";\nimport { TableMeta } from \"@worker/model\";\n\nexport class SchemaChecker {\n    table: TableMeta;\n    constructor(table: TableMeta) {\n        this.table = table;\n    }\n\n    check(setValue: object, tblName: string) {\n        let log: LogHelper;\n        if (typeof setValue === DATA_TYPE.Object) {\n            if (this.table) {\n                // loop through table column and find data is valid\n                this.table.columns.every((column) => {\n                    if (column.name in setValue) {\n                        log = this.checkByColumn_(column, setValue[column.name]);\n                    }\n                    return log ? false : true;\n                });\n            }\n            else {\n                log = new LogHelper(ERROR_TYPE.TableNotExist, { tableName: tblName });\n            }\n        }\n        else {\n            log = new LogHelper(ERROR_TYPE.NotObject);\n        }\n        return log;\n    }\n\n\n\n    private checkByColumn_(column: IColumn, value) {\n        // check not null schema\n        if (column.notNull === true && isNull(value)) {\n            return new LogHelper(ERROR_TYPE.NullValue, { ColumnName: column.name });\n        }\n\n        // check datatype\n        const type = getDataType(value);\n        const checkFurther = value != null;\n        if (column.dataType && checkFurther) {\n            if (type !== column.dataType && type !== 'object') {\n                return new LogHelper(ERROR_TYPE.WrongDataType, { column: column.name });\n            }\n        }\n\n        // check allowed operators\n        if (checkFurther && type === 'object') {\n            const allowedOp = ['+', '-', '*', '/', '{push}'];\n            for (const prop in value) {\n                if (allowedOp.indexOf(prop) < 0 && column.dataType && type !== column.dataType) {\n                    return new LogHelper(ERROR_TYPE.WrongDataType, { column: column.name });\n                }\n            }\n        }\n    }\n}","import { IInsertQuery, DATA_TYPE, ERROR_TYPE, ISelectQuery, QUERY_OPTION, IUpdateQuery, API } from \"@/common\";\nimport { LogHelper, getDataType } from \"@/worker/utils\";\nimport { DbMeta } from \"../model\";\nimport { ValuesChecker } from \"@worker/executors/insert\";\nimport { SchemaChecker } from \"./update/schema_checker\";\n\nexport class QueryHelper {\n    db: DbMeta;\n\n    constructor(dbSchema: DbMeta) {\n        this.db = dbSchema;\n    }\n\n    validate(api: API, query: IInsertQuery | ISelectQuery | IUpdateQuery) {\n        switch (api) {\n            case API.Select:\n            case API.Remove:\n            case API.Count:\n                return this.checkSelect(query as ISelectQuery);\n            case API.Insert:\n                return this.checkInsertQuery(query as IInsertQuery);\n            case API.Update:\n                return this.checkUpdate(query as IUpdateQuery);\n        }\n    }\n\n    private getTable_(tableName: string) {\n        return this.db.tables.find(q => q.name === tableName);\n    }\n\n    isInsertQryValid(query: IInsertQuery) {\n        const table = this.getTable_(query.into);\n        let log: LogHelper;\n        if (table) {\n            switch (getDataType(query.values)) {\n                case DATA_TYPE.Array:\n                    break;\n                case DATA_TYPE.Null:\n                    log = new LogHelper(ERROR_TYPE.NoValueSupplied);\n                    break;\n                default:\n                    log = new LogHelper(ERROR_TYPE.NotArray);\n            }\n        }\n        else {\n            log = new LogHelper(ERROR_TYPE.TableNotExist, { tableName: query.into });\n        }\n        return {\n            table, log\n        };\n    }\n\n    private checkUpdate(query: IUpdateQuery) {\n        let err = new SchemaChecker(this.getTable_(query.in)).\n            check(query.set, query.in);\n        if (err) return err;\n        if (query.where != null) {\n            err = this.checkForNullInWhere_(query);\n            if (err) return err;\n            this.addGreatAndLessToNotOp_(query as any);\n        }\n    }\n\n    private checkSelect(query: ISelectQuery) {\n        if (!query.store) {\n            const table = this.getTable_(query.from);\n            if (!table) {\n                return new LogHelper(ERROR_TYPE.TableNotExist,\n                    { tableName: query.from }\n                );\n            }\n        }\n\n        if (query.where) {\n            const err = this.checkForNullInWhere_(query);\n            if (err) return err;\n            this.addGreatAndLessToNotOp_(query);\n        }\n    }\n\n    private checkForNullInWhere_(query): LogHelper {\n        for (const columnName in query.where) {\n            if (query.where[columnName] == null) {\n                return new LogHelper(ERROR_TYPE.NullValueInWhere, { column: columnName });\n            }\n        }\n    }\n\n    private addGreatAndLessToNotOp_(query: ISelectQuery) {\n        const whereQuery = query.where;\n        const containsNot = (qry: object, keys: string[]) => {\n            return keys.findIndex(key => qry[key][QUERY_OPTION.NotEqualTo] != null) >= 0;\n        };\n        const addToSingleQry = (qry, keys: string[]) => {\n            let value;\n            keys.forEach((prop) => {\n                value = qry[prop];\n                if (value[QUERY_OPTION.NotEqualTo] != null) {\n                    qry[prop][QUERY_OPTION.GreaterThan] = value[QUERY_OPTION.NotEqualTo];\n                    if (qry[QUERY_OPTION.Or] === undefined) {\n                        qry[QUERY_OPTION.Or] = {};\n                        qry[QUERY_OPTION.Or][prop] = {};\n                    }\n                    else if (qry[QUERY_OPTION.Or][prop] === undefined) {\n                        qry[QUERY_OPTION.Or][prop] = {};\n                    }\n                    qry[QUERY_OPTION.Or][prop][QUERY_OPTION.LessThan] = value[QUERY_OPTION.NotEqualTo];\n                    delete qry[prop][QUERY_OPTION.NotEqualTo];\n                }\n            });\n            return qry;\n        };\n        switch (getDataType(whereQuery)) {\n            case DATA_TYPE.Object:\n                const queryKeys = Object.keys(whereQuery);\n                if (containsNot(whereQuery, queryKeys)) {\n                    if (queryKeys.length === 1) {\n                        query.where = addToSingleQry(whereQuery, queryKeys);\n                    }\n                    else {\n                        const whereTmpQry = [];\n                        queryKeys.forEach((prop) => {\n                            whereTmpQry.push(addToSingleQry({ [prop]: whereQuery[prop] }, [prop]));\n                        });\n                        query.where = whereTmpQry;\n                    }\n                }\n                break;\n            default:\n                const whereTmp = [];\n                (whereQuery as object[]).forEach(qry => {\n                    const qryKeys = Object.keys(qry);\n                    if (containsNot(qry, qryKeys)) {\n                        qry = addToSingleQry(qry, qryKeys);\n                    }\n                    whereTmp.push(qry);\n                });\n                query.where = whereTmp;\n        }\n    }\n\n    private checkInsertQuery(query: IInsertQuery) {\n        const validResult = this.isInsertQryValid(query);\n        let table = validResult.table;\n        const error = validResult.log;\n        if (error) return error;\n        if (query.skipDataCheck) return;\n        const valueCheckerInstance = new ValuesChecker(table, table.autoIncColumnValue);\n        const { values, err } = valueCheckerInstance.checkAndModifyValues(query);\n        query.values = values;\n        return err;\n    }\n}","export * from \"./values_checker\";\nimport { IInsertQuery, promise, promiseAll, API, IDB_MODE } from \"@/common\";\nimport { Base } from \"@worker/executors/base\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { QueryHelper } from \"@worker/executors/query_helper\";\nimport { DbMeta } from \"@/worker/model\";\nimport { promiseReject } from \"@/worker/utils\";\nimport { MetaHelper } from \"@/worker/meta_helper\";\n\nexport class Insert extends Base {\n\n    query: IInsertQuery;\n\n    private valuesAffected_ = [];\n\n    constructor(query: IInsertQuery, util: IDBUtil) {\n        super();\n        if (query.validation == null) {\n            query.validation = true;\n        }\n        this.query = query;\n        this.util = util;\n        this.tableName = query.into;\n    }\n\n    execute(beforeInsert: () => Promise<any>) {\n        const db = this.db;\n        const err = new QueryHelper(db).validate(API.Insert, this.query);\n        if (err) return promiseReject(err);\n\n        return beforeInsert().then(_ => {\n            return this.insertData_(db).then(_ => {\n                return this.query.return ? this.valuesAffected_ : this.rowAffected\n            })\n        }).catch(err => {\n            this.util.abortTransaction();\n            return promiseReject(err);\n        })\n    }\n\n    private insertData_(db: DbMeta) {\n\n        let onInsertData;\n        let addMethod;\n\n        const query = this.query;\n        if (query.return) {\n            onInsertData = (value) => {\n                this.valuesAffected_.push(value);\n            };\n\n        }\n        else {\n            onInsertData = (value) => {\n                ++this.rowAffected;\n            };\n        }\n        addMethod = (() => {\n            const idbMethod = query.upsert ? \"put\" : \"add\";\n            if (query.ignore && !this.isTxQuery) {\n                return (value) => {\n                    const tx = this.util.con.transaction(query.into, IDB_MODE.ReadWrite);\n                    const objectStore = tx.objectStore(query.into);\n                    return objectStore[idbMethod](value);\n                };\n            }\n            if (!this.isTxQuery) {\n                this.util.createTransaction(\n                    [query.into, MetaHelper.tableName],\n                )\n            }\n            this.objectStore = this.util.objectStore(this.tableName);\n            return (value) => {\n                return this.objectStore[idbMethod](value);\n            };\n        })();\n\n        return promiseAll(\n            query.values.map((value) => {\n                return promise((res, rej) => {\n                    const addResult = addMethod(value);\n                    addResult.onerror = (err) => {\n                        if (query.ignore) {\n                            res();\n                        } else {\n                            rej(err);\n                        }\n                    }\n                    addResult.onsuccess = function () {\n                        onInsertData(value);\n                        res();\n                    };\n                });\n            })\n        ).then(() => {\n            MetaHelper.set(MetaHelper.dbSchema, db, this.util);\n        });\n    }\n}","import { setCrossBrowserIndexedDb } from \"@worker/utils\";\n\nexport const IS_WORKER = typeof (self as any).alert === 'undefined' && typeof ServiceWorkerGlobalScope === 'undefined';\nexport const IS_IDB_SUPPORTED = setCrossBrowserIndexedDb();","export const setCrossBrowserIndexedDb = () => {\n    try {\n        if (!indexedDB) {\n            indexedDB = (self as any).mozIndexedDB ||\n                (self as any).webkitIndexedDB || (self as any).msIndexedDB;\n        }\n        if (indexedDB) {\n            IDBTransaction = IDBTransaction ||\n                (self as any).webkitIDBTransaction || (self as any).msIDBTransaction;\n            (self as any).IDBKeyRange = (self as any).IDBKeyRange ||\n                (self as any).webkitIDBKeyRange || (self as any).msIDBKeyRange;\n        }\n        else {\n            return false;\n        }\n    } catch (ex) {\n        return false;\n    }\n    return true;\n};","export const isArray = (value) => {\n    return Array.isArray(value);\n};","export const getKeys = (value) => {\n    return Object.keys(value);\n};","import { getKeys } from \"./get_keys\"\n\nexport const getLength = (value): number => {\n    return getKeys(value).length;\n}","export const getObjectFirstKey = (value) => {\n    for (const key in value) {\n        return key;\n    }\n};","import { ICaseOption, QUERY_OPTION } from \"@/common\";\n\nexport class ThenEvaluator {\n    private columnName_: string;\n    private value;\n    private caseQuery_: { [columnName: string]: [ICaseOption] };\n    private caseColumnQuery_: ICaseOption[];\n    private length_: number;\n\n    setCaseAndValue(caseQuery: any, value) {\n        this.caseQuery_ = caseQuery;\n        this.setValue(value);\n    }\n\n    setCaseAndColumn(caseQuery: { [columnName: string]: [ICaseOption] }, columnName: string) {\n        this.caseQuery_ = caseQuery;\n        this.setColumn(columnName);\n        return this;\n    }\n\n    setColumn(columnName: string) {\n        this.columnName_ = columnName;\n        this.caseColumnQuery_ = this.caseQuery_[this.columnName_];\n        this.length_ = this.caseColumnQuery_.length;\n        return this;\n    }\n\n    setValue(value) {\n        this.value = value;\n        return this;\n    }\n\n    evaluate() {\n        for (let i = 0; i < this.length_; i++) {\n            if (this.checkCase_(this.caseColumnQuery_[i]) === true) {\n                return this.caseColumnQuery_[i].then;\n            }\n        }\n        const lastThen = this.caseColumnQuery_[this.length_ - 1].then;\n        return lastThen == null ? this.value[this.columnName_] : lastThen;\n    }\n\n    private checkCase_(cond: ICaseOption) {\n        let queryOption;\n        for (queryOption in cond) {\n            switch (queryOption) {\n                case QUERY_OPTION.GreaterThan:\n                    if (this.value[this.columnName_] > cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.Equal:\n                    if (this.value[this.columnName_] === cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.LessThan:\n                    if (this.value[this.columnName_] < cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.GreaterThanEqualTo:\n                    if (this.value[this.columnName_] >= cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.LessThanEqualTo:\n                    if (this.value[this.columnName_] <= cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.NotEqualTo:\n                    if (this.value[this.columnName_] !== cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.Between:\n                    if (this.value[this.columnName_] > cond[queryOption].low && this.value[this.columnName_] < cond[queryOption].high) {\n                        return true;\n                    } break;\n            }\n            return false;\n        }\n    }\n}","import { Select } from \"./\";\nimport { promise } from \"@/common\";\nimport { BaseFetch } from \"../base_fetch\";\n\nexport const getCursorOnSuccess = function (this: Select, simpleFn, limitFn, skipFn, skipAndLimitFn) {\n    if (this.limitAtEnd === false && this.skipAtEnd === false) {\n        if (this.skipRecord) {\n            return this.limitRecord ? skipAndLimitFn : skipFn\n        }\n        if (this.limitRecord) {\n            return limitFn;\n        }\n    }\n    return simpleFn;\n}\n\nexport const executeWhereLogic = function (this: BaseFetch, column, value, op, dir) {\n\n    value = op ? value[op] : value;\n    const cursorRequest = this.objectStore.index(column).openCursor(\n        this.util.keyRange(value, op),\n        dir\n    );\n\n    const onSuccess = getCursorOnSuccess.call(\n        this,\n        executeSimpleForWhere_,\n        executeLimitForWhere_,\n        executeSkipForWhere_,\n        executeSkipAndLimitForWhere_\n    );\n\n    return promise<any>((res, rej) => {\n        cursorRequest.onerror = rej;\n        cursorRequest.onsuccess = onSuccess.call(this, res);\n    })\n\n}\n\nconst executeSkipAndLimitForWhere_ = function (this: Select, onFinish) {\n    let recordSkipped = false;\n    return (e: any) => {\n        const cursor: IDBCursorWithValue = e.target.result;\n        if (cursor) {\n            if (recordSkipped && this.results.length !== this.limitRecord) {\n                if (this.shouldAddValue(cursor)) {\n                    this.pushResult(cursor.value);\n                }\n                cursor.continue();\n            }\n            else {\n                recordSkipped = true;\n                cursor.advance(this.skipRecord);\n            }\n        }\n        else {\n            onFinish();\n        }\n    };\n}\n\nconst executeSkipForWhere_ = function (this: Select, onFinish) {\n    let recordSkipped = false;\n    return (e: any) => {\n        const cursor = e.target.result;\n        if (cursor) {\n            if (recordSkipped) {\n                if (this.shouldAddValue(cursor)) {\n                    this.pushResult(cursor.value);\n                }\n                cursor.continue();\n            }\n            else {\n                recordSkipped = true;\n                cursor.advance(this.skipRecord);\n            }\n        }\n        else {\n            onFinish();\n        }\n    };\n}\n\nexport const executeLimitForWhere_ = function (this: Select, onFinish) {\n    return (e: any) => {\n        const cursor = e.target.result;\n        if (cursor && this.results.length !== this.limitRecord) {\n            if (this.shouldAddValue(cursor)) {\n                this.pushResult(cursor.value);\n            }\n            cursor.continue();\n        }\n        else {\n            onFinish();\n        }\n    };\n\n}\n\nexport const executeSimpleForWhere_ = function (this: Select, onFinish) {\n    return (e: any) => {\n        const cursor: IDBCursorWithValue = e.target.result;\n        if (cursor) {\n            if (this.shouldAddValue(cursor)) {\n                this.pushResult(cursor.value);\n            }\n            cursor.continue();\n        }\n        else {\n            onFinish();\n        }\n    };\n}","import { Select } from \"./index\";\nimport { LogHelper, promiseReject } from \"@/worker/utils\";\nimport { ERROR_TYPE, IOrderQuery, promise, promiseResolve } from \"@/common\";\nimport { getCursorOnSuccess } from \"./where\";\n\nexport const executeWhereUndefinedLogic = function (this: Select) {\n    let cursorRequest: IDBRequest;\n    const query = this.query;\n    const store = query.store;\n    if (store) {\n        this.results = store as any[];\n        this.setLimitAndSkipEvaluationAtEnd_();\n        return promiseResolve();\n    }\n    const orderQuery = query.order;\n    const objectStore = this.objectStore;\n    if (orderQuery && (orderQuery as IOrderQuery).idbSorting !== false && (orderQuery as IOrderQuery).by) {\n        if (objectStore.indexNames.contains((orderQuery as IOrderQuery).by as string)) {\n            const orderType: IDBCursorDirection = (orderQuery as IOrderQuery).type &&\n                (orderQuery as IOrderQuery).type.toLowerCase() === 'desc' ? 'prev' : 'next';\n            this.sorted = true;\n            cursorRequest = objectStore.index((orderQuery as IOrderQuery).by as string).\n                openCursor(null, orderType);\n        }\n        else {\n            return promiseReject(\n                new LogHelper(\n                    ERROR_TYPE.ColumnNotExist,\n                    { column: (orderQuery as IOrderQuery).by, isOrder: true }\n                )\n            );\n        }\n    }\n    else {\n        cursorRequest = objectStore.openCursor();\n    }\n\n    const onSuccess = getCursorOnSuccess.call(\n        this,\n        executeSimple,\n        executeLimit,\n        executeSkip,\n        executeSkipAndLimit\n    );\n\n    return promise<void>((res, rej) => {\n        cursorRequest.onerror = rej;\n        cursorRequest.onsuccess = onSuccess.call(this, res);\n    });\n}\n\nconst executeSkipAndLimit = function (this: Select, onFinished) {\n    let recordSkipped = false,\n        cursor: IDBCursorWithValue;\n    return (e) => {\n        cursor = (e as any).target.result;\n        if (cursor) {\n            if (recordSkipped && this.results.length !== this.limitRecord) {\n                this.pushResult(cursor.value);\n                cursor.continue();\n            }\n            else {\n                recordSkipped = true;\n                cursor.advance(this.skipRecord);\n            }\n        } else {\n            onFinished();\n        }\n    };\n}\n\nconst executeSkip = function (this: Select, onFinished) {\n    let recordSkipped = false,\n        cursor;\n    return (e: any) => {\n        cursor = e.target.result;\n        if (cursor) {\n            if (recordSkipped) {\n                this.pushResult(cursor.value);\n                cursor.continue();\n            }\n            else {\n                recordSkipped = true;\n                cursor.advance(this.skipRecord);\n            }\n        } else {\n            onFinished();\n        }\n    };\n}\n\nconst executeSimple = function (this: Select, onFinished) {\n    let cursor;\n    return (e: any) => {\n        cursor = e.target.result;\n        if (cursor) {\n            this.pushResult(cursor.value);\n            (cursor as any).continue();\n        }\n        else {\n            onFinished();\n        }\n    };\n}\n\nconst executeLimit = function (this: Select, onFinished) {\n    let cursor;\n    return (e: any) => {\n        cursor = e.target.result;\n        if (cursor && this.results.length !== this.limitRecord) {\n            this.pushResult(cursor.value);\n            cursor.continue();\n        } else {\n            onFinished();\n        }\n    };\n}\n","export const removeSpace = (value: string) => {\n    return value.replace(/\\s/g, '');\n};","import { Select } from \"./\";\nimport { removeSpace, getDataType, LogHelper } from \"@/worker/utils\";\nimport { ERROR_TYPE, DATA_TYPE, ICaseOption, IColumn, IOrderQuery } from \"@/common\";\n\nexport const processGroupDistinctAggr = function (this: Select) {\n    const query = this.query;\n    if (query.distinct) {\n        const groupBy = [];\n        const result = this.results[0];\n        for (const key in result) {\n            groupBy.push(key);\n        }\n        const primaryKey = this.primaryKey();\n        const index = groupBy.indexOf(primaryKey);\n        groupBy.splice(index, 1);\n        query.groupBy = groupBy.length > 0 ? groupBy : null;\n    }\n    if (query.groupBy) {\n        if (query.aggregate) {\n            this.executeAggregateGroupBy();\n        }\n        else {\n            this.processGroupBy();\n        }\n    }\n    else if (query.aggregate) {\n        this.processAggregateQry();\n    }\n};\n\nconst getOrderColumnInfo = function (this: Select, orderColumn: string) {\n    let column: IColumn;\n    if (!this.query.store) {\n        if (this.query.join == null) {\n            column = this.getColumnInfo(orderColumn);\n        }\n        else {\n            const splittedByDot = removeSpace(orderColumn).split(\".\");\n            const joinOrderColumn = splittedByDot[1];\n            if (process.env.NODE_ENV !== 'production' && joinOrderColumn == null) {\n                new LogHelper(ERROR_TYPE.ColumnNotExist,\n                    { column: orderColumn, isOrder: true, isJoin: true }\n                ).throw()\n            }\n            column = this.getColumnInfo(joinOrderColumn, splittedByDot[0]);\n        }\n    }\n    if (column == null) {\n        const valueFromFirstColumn = this.results[0][orderColumn];\n        if (valueFromFirstColumn) {\n            return {\n                dataType: getDataType(valueFromFirstColumn),\n                name: orderColumn\n            } as IColumn;\n        }\n        throw new LogHelper(ERROR_TYPE.ColumnNotExist,\n            { column: orderColumn, isOrder: true }\n        )\n\n    }\n    return column;\n}\n\nconst compareStringInDesc_ = (a: string, b: string) => {\n    return b.localeCompare(a);\n}\n\nconst compareStringinAsc_ = (a: string, b: string) => {\n    return a.localeCompare(b);\n}\n\nconst compareDefaultInDesc_ = (a: string, b) => {\n    return new String(b).localeCompare(a);\n}\n\nconst compareDefaultinAsc_ = (a, b: string) => {\n    return new String(a).localeCompare(b);\n}\n\nconst compareNumberInDesc_ = (a: number, b: number) => {\n    return b - a;\n}\n\nconst compareNumberinAsc_ = (a: number, b: number) => {\n    return a - b;\n}\n\nconst compareDateInDesc_ = (a: Date, b: Date) => {\n    return b.getTime() - a.getTime();\n}\n\nconst compareDateInAsc_ = (a: Date, b: Date) => {\n    return a.getTime() - b.getTime();\n}\n\nconst getValueComparer_ = (column: IColumn, order: IOrderQuery): (a, b) => number => {\n    switch (column.dataType) {\n        case DATA_TYPE.String:\n            return order.type === 'asc' ? compareStringinAsc_ : compareStringInDesc_;\n        case DATA_TYPE.Number:\n            return order.type === 'asc' ? compareNumberinAsc_ : compareNumberInDesc_;\n        case DATA_TYPE.DateTime:\n            return order.type === 'asc' ? compareDateInAsc_ : compareDateInDesc_;\n        default:\n            return order.type === 'asc' ? compareDefaultinAsc_ : compareDefaultInDesc_;\n    }\n\n}\n\nconst orderBy_ = function (this: Select, order: IOrderQuery) {\n    order.type = getOrderType_(order.type);\n    let orderColumn = order.by;\n    const thenEvaluator = this.thenEvaluator;\n    if (orderColumn != null && typeof orderColumn === DATA_TYPE.Object) {\n        const caseQuery = orderColumn as { [columnName: string]: [ICaseOption] };\n        const getValInAscDesc = (stringComparer, numberComparer) => {\n            return (value1, value2) => {\n                for (const columnName in caseQuery) {\n                    thenEvaluator.setCaseAndValue(caseQuery, value1);\n                    const column1 = thenEvaluator.setColumn(columnName).evaluate();\n                    thenEvaluator.setCaseAndValue(caseQuery, value2);\n                    const column2 = thenEvaluator.setColumn(columnName).evaluate();\n                    switch (typeof value1[column1]) {\n                        case DATA_TYPE.String:\n                            return stringComparer(value1[column1], value2[column2]);\n                        default:\n                            return numberComparer(value1[column1], value2[column2]);\n                    }\n                }\n            }\n        };\n        let sortMethod = order.type === 'asc' ?\n            getValInAscDesc(compareStringinAsc_, compareNumberinAsc_) :\n            getValInAscDesc(compareStringInDesc_, compareNumberInDesc_);\n\n        this.results.sort(sortMethod);\n    }\n    else {\n        const columnInfo = getOrderColumnInfo.call(this, orderColumn as string);\n        if (columnInfo != null) {\n            const orderMethod = getValueComparer_(columnInfo, order);\n            orderColumn = columnInfo.name;\n            if (order.case == null) {\n                this.results.sort((a, b) => {\n                    return orderMethod(a[orderColumn as string], b[orderColumn as string]);\n                });\n            }\n            else {\n                thenEvaluator.setCaseAndColumn({ [orderColumn as string]: order.case }, orderColumn as string);\n                this.results.sort((a, b) => {\n                    return orderMethod(\n                        thenEvaluator.setValue(a).evaluate(),\n                        thenEvaluator.setValue(b).evaluate()\n                    );\n                });\n            }\n        }\n    }\n\n}\n\nconst getOrderType_ = (type: string) => {\n    return type == null ? 'asc' : type.toLowerCase();\n}\n\nexport const processOrderBy = function (this: Select) {\n    const order = this.query.order;\n    if (order && this.results.length > 0 && !this.sorted) {\n        const orderQueryType = getDataType(order);\n        if (orderQueryType === DATA_TYPE.Object) {\n            orderBy_.call(this, order);\n        }\n        else if (orderQueryType === DATA_TYPE.Array) {\n            orderBy_.call(this, order[0]);\n            for (let i = 1, length = (order as any).length; i < length; i++) {\n                const prevOrderQueryBy = order[i - 1].by;\n                const currentOrderQuery: IOrderQuery = order[i];\n                let currentorderQueryBy = currentOrderQuery.by;\n                const orderColumnDetail = getOrderColumnInfo.call(this, currentorderQueryBy as string);\n                if (orderColumnDetail != null) {\n                    currentorderQueryBy = orderColumnDetail.name;\n                    currentOrderQuery.type = getOrderType_(currentOrderQuery.type);\n                    const orderMethod = getValueComparer_(orderColumnDetail, currentOrderQuery);\n                    this.results.sort((a, b) => {\n                        if (a[prevOrderQueryBy] === b[prevOrderQueryBy]) {\n                            return orderMethod(\n                                a[currentorderQueryBy as string],\n                                b[currentorderQueryBy as string]\n                            );\n                        }\n                        return 0;\n                    });\n                }\n            }\n        }\n    }\n}\n\nexport const processAggregateQry = function (this: Select) {\n    const datas = this.results;\n    const datasLength = datas.length;\n    const results = {};\n    let columnToAggregate;\n\n    const getCount = () => {\n        let result = 0;\n        for (const i in datas) {\n            result += datas[i][columnToAggregate] ? 1 : 0;\n        }\n        return result;\n    };\n    const getMax = () => {\n        let result = 0;\n        for (const i in datas) {\n            result = result > datas[i][columnToAggregate] ?\n                result : datas[i][columnToAggregate];\n        }\n        return result;\n    };\n    const getMin = () => {\n        let result = Infinity, value = Infinity;\n        for (const i in datas) {\n            value = datas[i][columnToAggregate] ?\n                datas[i][columnToAggregate] : Infinity;\n            result = result < value ? result : value;\n        }\n        return result;\n    };\n    const getSum = () => {\n        let result = 0;\n        for (const i in datas) {\n            result += datas[i][columnToAggregate];\n        }\n        return result;\n    };\n    const getAvg = () => {\n        return getSum() / datasLength;\n    };\n    const aggregateQry = this.query.aggregate;\n    for (const prop in aggregateQry) {\n        const aggregateColumn = aggregateQry[prop];\n        const aggregateValType = getDataType(aggregateColumn);\n        let aggregateCalculator;\n        switch (prop) {\n            case 'count':\n                aggregateCalculator = getCount; break;\n            case 'max':\n                aggregateCalculator = getMax; break;\n            case 'min':\n                aggregateCalculator = getMin; break;\n            case 'sum':\n                aggregateCalculator = getSum; break;\n            case 'avg':\n                aggregateCalculator = getAvg;\n        }\n        switch (aggregateValType) {\n            case DATA_TYPE.String:\n                columnToAggregate = aggregateColumn;\n                results[`${prop}(${columnToAggregate})`] = aggregateCalculator();\n                break;\n            case DATA_TYPE.Array:\n                for (const key in aggregateColumn) {\n                    columnToAggregate = aggregateColumn[key];\n                    results[`${prop}(${columnToAggregate})`] = aggregateCalculator();\n                }\n        }\n    }\n\n    // add results to the first index of result\n    for (const prop in results) {\n        datas[0][prop] = results[prop];\n    }\n    this.results = [datas[0]];\n}","import { OCCURENCE } from \"@/common\";\n\nexport const getRegexFromLikeExpression = (likeExpression: string) => {\n    const filterValues = likeExpression.split('%');\n    let filterValue: string;\n    let occurence: OCCURENCE;\n    if (filterValues[1]) {\n        filterValue = filterValues[1];\n        occurence = filterValues.length > 2 ? OCCURENCE.Any : OCCURENCE.Last;\n    }\n    else {\n        filterValue = filterValues[0];\n        occurence = OCCURENCE.First;\n    }\n    switch (occurence) {\n        case OCCURENCE.First:\n            return new RegExp(`^${filterValue}`, 'i');\n        case OCCURENCE.Last:\n            return new RegExp(`${filterValue}$`, 'i');\n        default:\n            return new RegExp(`${filterValue}`, 'i');\n    }\n}","import { getDataType } from \"./get_data_type\";\n\nconst isObject = (value) => {\n    return getDataType(value) === 'object' && !(value instanceof RegExp);\n};\n\nexport const clone = (obj) => {\n    if (isObject(obj)) {\n        const copy = {};\n        for (const i in obj) {\n            copy[i] = obj[i] != null && isObject(obj[i]) ? clone(obj[i]) : obj[i];\n        }\n        return copy;\n    }\n    return obj;\n};","import { getDataType } from \"./get_data_type\"\nimport { QUERY_OPTION, DATA_TYPE } from \"@/common\";\nimport { isArray } from \"./is_array\";\n\nexport const compare = (value, compareValue, symbol?) => {\n    const type1 = getDataType(value);\n    const type2 = getDataType(compareValue);\n\n    if (type1 !== type2) return false;\n    if (type1 === DATA_TYPE.DateTime) {\n        value = value.getTime();\n        compareValue = compareValue.getTime();\n    }\n    switch (symbol) {\n        // greater than\n        case QUERY_OPTION.GreaterThan:\n            return value > compareValue;\n        // less than\n        case QUERY_OPTION.LessThan:\n            return value < compareValue;\n        // less than equal\n        case QUERY_OPTION.LessThanEqualTo:\n            return value <= compareValue;\n        // greather than equal\n        case QUERY_OPTION.GreaterThanEqualTo:\n            return value >= compareValue;\n        // Not equal to\n        case QUERY_OPTION.NotEqualTo:\n            return value !== compareValue;\n        default:\n            if (type1 === 'array') {\n                if (value.length !== compareValue.length) return false;\n                let status;\n                value.every((item, index) => {\n                    status = item === compareValue[index];\n                    return status;\n                });\n                return status;\n            }\n            return value === compareValue;\n    }\n}","import { QUERY_OPTION } from \"@/common\";\nimport { getDataType, clone, compare, getRegexFromLikeExpression, isArray } from \"@worker/utils\";\n\n/**\n * For matching the different column value existance for where option\n * \n * @export\n * @class WhereChecker\n */\nexport class WhereChecker {\n  where: object;\n  checkFlag: boolean;\n\n  constructor(where: object, checkFlag: boolean) {\n    this.where = clone(where);\n    this.checkFlag = checkFlag;\n  }\n\n  remove(props: string[]) {\n    const last = props.pop();\n    const value = props.reduce((prev, curr) => prev && prev[curr], this.where);\n    delete value[last];\n  }\n\n  check(rowValue) {\n    let status = true;\n    if (!this.checkFlag) return status;\n    const where = this.where;\n    for (let columnName in where) {\n      if (!status) {\n        return status;\n      }\n      const whereColumnValue = where[columnName];\n      const columnValue = rowValue[columnName];\n      const isArrayColumnValue = isArray(columnValue);\n      const isArrayWhereColumnValue = isArray(whereColumnValue);\n      const executeCompare = (executor: Function) => {\n        if (isArrayColumnValue && !isArrayWhereColumnValue) {\n          columnValue.every(q => {\n            status = executor(q);\n            return !status;\n          })\n        }\n        else {\n          status = executor(columnValue);\n        }\n        return\n      }\n\n      if (getDataType(whereColumnValue) === \"object\") {\n        for (const key in whereColumnValue) {\n          if (!status) {\n            return status;\n          }\n          switch (key) {\n            case QUERY_OPTION.In:\n              executeCompare((compareValue) => {\n                return this.checkIn(whereColumnValue[QUERY_OPTION.In], compareValue);\n              })\n              break;\n            case QUERY_OPTION.Like:\n              executeCompare((compareValue) => {\n                return this.checkLike_(columnName, compareValue);\n              })\n              break;\n            case QUERY_OPTION.Regex:\n              executeCompare((compareValue) => {\n                return this.checkRegex(columnName, compareValue);\n              })\n              break;\n            case QUERY_OPTION.Between:\n            case QUERY_OPTION.GreaterThan:\n            case QUERY_OPTION.LessThan:\n            case QUERY_OPTION.GreaterThanEqualTo:\n            case QUERY_OPTION.LessThanEqualTo:\n            case QUERY_OPTION.NotEqualTo:\n              executeCompare((compareValue) => {\n                return this.checkComparisionOp_(columnName, compareValue, key);\n              })\n              break;\n            default:\n              status = false;\n          }\n        }\n      }\n      else {\n        executeCompare((storedValue) => {\n          return compare(whereColumnValue, storedValue);\n        });\n      }\n    }\n    return status;\n  }\n\n  private checkIn(whereColumnValue: any[], value) {\n    return whereColumnValue.find(q => compare(q, value)) != null;\n  }\n\n  private checkLike_(column, value) {\n    return getRegexFromLikeExpression(this.where[column][QUERY_OPTION.Like]).test(value);\n  }\n\n  private checkRegex(column, value) {\n    return this.where[column][QUERY_OPTION.Regex].test(value);\n  }\n\n  private checkComparisionOp_(column, value, symbol) {\n    const compareValue = this.where[column][symbol];\n    if (symbol != QUERY_OPTION.Between) {\n      return compare(value, compareValue, symbol);\n    }\n    return compare(value, compareValue.low, '>=') &&\n      compare(value, compareValue.high, '<=');\n  }\n}","import { Base } from \"./base\";\nimport { ISelectQuery, QUERY_OPTION, ERROR_TYPE } from \"@/common\";\nimport { getRegexFromLikeExpression, promiseReject } from \"@worker/utils\";\nimport { LogHelper, getObjectFirstKey, getDataType, getLength } from \"@worker/utils\";\nimport { WhereChecker } from \"./where_checker\";\nimport { executeWhereLogic } from \"./select/where\";\nimport { executeInLogic } from \"./select/in\";\nimport { executeRegexLogic } from \"./select/regex\";\n\nexport class BaseFetch extends Base {\n    query: ISelectQuery;\n    whereChecker: WhereChecker;\n    executeWhereLogic: typeof executeWhereLogic;\n    skipRecord;\n    limitRecord;\n    limitAtEnd = false;\n    skipAtEnd = false;\n    executeInLogic: typeof executeInLogic;\n    executeRegexLogic: typeof executeRegexLogic;\n\n    resultCount: number;\n\n    protected shouldAddValue: (value) => boolean;\n    protected goToWhereLogic() {\n        const query = this.query as ISelectQuery;\n        const whereQuery = query.where;\n        let firstColumn = (() => {\n            for (const key in whereQuery) {\n                if (this.objectStore.indexNames.contains(key)) {\n                    return key;\n                }\n            }\n        })();\n        if (firstColumn == null) {\n            firstColumn = getObjectFirstKey(whereQuery);\n            if (!query.store) {\n                return promiseReject(\n                    new LogHelper(ERROR_TYPE.NoIndexFound, { column: firstColumn })\n                );\n            }\n        }\n        const value = whereQuery[firstColumn];\n        if (getDataType(value) === 'object') {\n            const checkFlag = getLength(value) > 1 ||\n                getLength(whereQuery) > 1\n\n            this.whereChecker = new WhereChecker(whereQuery, checkFlag);\n            const key = getObjectFirstKey(value);\n            this.whereChecker.remove([firstColumn, key]);\n            switch (key) {\n                case QUERY_OPTION.Like: {\n                    const regexVal = getRegexFromLikeExpression(value[QUERY_OPTION.Like]);\n                    return this.executeRegexLogic(firstColumn, regexVal);\n                }\n                case QUERY_OPTION.Regex:\n                    return this.executeRegexLogic(firstColumn, value[QUERY_OPTION.Regex]);\n                case QUERY_OPTION.In:\n                    return this.executeInLogic(\n                        firstColumn, value[QUERY_OPTION.In]\n                    );\n                case QUERY_OPTION.Between:\n                case QUERY_OPTION.GreaterThan:\n                case QUERY_OPTION.LessThan:\n                case QUERY_OPTION.GreaterThanEqualTo:\n                case QUERY_OPTION.LessThanEqualTo:\n                    return this.executeWhereLogic(firstColumn, value, key, \"next\");\n                case QUERY_OPTION.Aggregate: break;\n                default:\n                    return this.executeWhereLogic(firstColumn, value, null, \"next\");\n            }\n        }\n        else {\n            const checkFlag = getLength(whereQuery) > 1;\n            this.whereChecker = new WhereChecker(whereQuery, checkFlag);\n            this.whereChecker.remove([firstColumn]);\n            return this.executeWhereLogic(firstColumn, value, null, \"next\");\n        }\n    }\n\n}","import { BaseFetch } from \"../base_fetch\";\nimport { Select } from \".\";\nimport { promise } from \"@/common\";\nimport { executeLimitForWhere_, executeSimpleForWhere_, getCursorOnSuccess } from \"./where\";\n\n\nexport const executeRegexLogic = function (this: BaseFetch, column, exp: RegExp) {\n\n    let skip = this.skipRecord;\n    const skipOrPush = (val) => {\n        if (skip === 0) {\n            (this as Select)['pushResult'](val);\n        }\n        else {\n            --skip;\n        }\n    };\n    this.shouldAddValue = (cursor) => {\n        return exp.test(cursor.key) &&\n            this.whereChecker.check(cursor.value);\n    };\n\n    const cursorRequest = this.objectStore.index(column).openCursor();\n\n    const onSuccess = getCursorOnSuccess.call(\n        this,\n        executeSimpleForWhere_,\n        executeLimitForWhere_,\n        executeSkipForWhere_,\n        executeSkipAndLimitForWhere_\n    );\n\n    return promise<any>((res, rej) => {\n        cursorRequest.onerror = rej;\n        cursorRequest.onsuccess = onSuccess.call(this, res, skipOrPush);\n    })\n\n}\n\nexport const executeSkipAndLimitForWhere_ = function (this: Select, onFinish, skipOrPush) {\n    return (e: any) => {\n        const cursor = e.target.result;\n        if (this.results.length !== this.limitRecord && cursor) {\n            if (this.shouldAddValue(cursor)) {\n                skipOrPush(cursor.value);\n            }\n            cursor.continue();\n        } else {\n            onFinish();\n        }\n    };\n}\n\nexport const executeSkipForWhere_ = function (this: Select, onFinish, skipOrPush) {\n    return (e: any) => {\n        const cursor = e.target.result;\n        if (cursor) {\n            if (this.shouldAddValue(cursor)) {\n                skipOrPush((cursor.value));\n            }\n            cursor.continue();\n        } else {\n            onFinish();\n        }\n    };\n}\n\n\n\n\n","import { Select } from \"./\";\nimport { IJoinQuery, DATA_TYPE, ERROR_TYPE, ISelectQuery, IErrorType } from \"@/common\";\nimport { getDataType, LogHelper, removeSpace, promiseReject, getKeys, getLength } from \"@/worker/utils\";\nimport { WhereChecker } from \"@executors/where_checker\";\n\n\nexport const executeJoinQuery = function (this: Select) {\n    return new Join(this).execute();\n}\n\ninterface JoinQueryWithInfo extends IJoinQuery {\n    joinTableInfo: JoinTableInfo\n}\n\nclass Join {\n\n    private joinQueryStack_: JoinQueryWithInfo[] = [];\n    private currentQueryStackIndex_ = 0;\n    tablesFetched = [];\n    results = [];\n\n    select: Select;\n    constructor(select: Select) {\n        this.select = select;\n    }\n\n    get query() {\n        return this.select.query;\n    }\n\n    getTable(name: string) {\n        return this.select.table(name);\n    }\n\n    private executeSelect(query: ISelectQuery) {\n        return new Select(query, this.select.util).\n            execute();\n    }\n\n    execute() {\n        const query = this.query;\n        this.joinQueryStack_ = getDataType(query.join) === DATA_TYPE.Object ?\n            [query.join as JoinQueryWithInfo] : query.join as JoinQueryWithInfo[];\n        // get the data for first table\n        const tableName = query.from;\n        const tablesToFetch = [];\n        if (tableName) {\n            tablesToFetch.push(tableName);\n        }\n        const joinQueryStack = this.joinQueryStack_;\n        for (let i = 0, length = joinQueryStack.length; i < length; i++) {\n            const item = joinQueryStack[i];\n            let jointblInfo = this.getJoinTableInfo_(item.on);\n            // table 1 is fetched & table2 needs to be fetched for join\n            if (item.with === jointblInfo.table1.table) {\n                jointblInfo = {\n                    table1: jointblInfo.table2,\n                    table2: jointblInfo.table1\n                };\n            }\n\n            const err = this.checkJoinQuery_(jointblInfo, item);\n            if (err) {\n                return promiseReject(err);\n            }\n            joinQueryStack[i].joinTableInfo = jointblInfo;\n            if (item.with) {\n                tablesToFetch.push(item.with)\n            }\n        }\n\n        if (!this.select.isTxQuery && tablesToFetch.length > 0) {\n            this.select.util.createTransaction(tablesToFetch);\n        }\n\n        const whereQuery = query.where;\n        // remove column which not exist in first table\n        if (whereQuery && !query.store) {\n            const table = this.getTable(tableName);\n            const removeJoinColumn = (whereQryParam) => {\n                let whereQryAfterJoin;\n                if (Array.isArray(whereQryParam)) {\n                    whereQryAfterJoin = [];\n                    whereQryParam = whereQryParam.filter((qry) => {\n                        const result = removeJoinColumn(qry);\n                        if (Object.keys(result.whereQryAfterJoin).length > 0) {\n                            whereQryAfterJoin.push(result.whereQryAfterJoin);\n                        }\n                        return !result.isWhereEmpty\n                    });\n                }\n                else {\n                    whereQryAfterJoin = {};\n                    for (const column in whereQryParam) {\n                        switch (column) {\n                            case \"or\":\n                                const filteredOr = {};\n                                const whereQryOr = whereQryParam[column];\n                                for (const orColumn in whereQryOr) {\n                                    const columnInTable = table.columns.find(q => q.name === orColumn);\n                                    if (!columnInTable) {\n                                        filteredOr[orColumn] = whereQryOr[orColumn];\n                                    }\n                                }\n                                if (getLength(filteredOr) > 0) {\n                                    whereQryAfterJoin['or'] = filteredOr;\n                                    for (const orColumn in filteredOr) {\n                                        delete whereQryOr[orColumn];\n                                    }\n                                }\n                                break;\n                            default:\n                                const columnInTable = table.columns.find(q => q.name === column);\n                                if (!columnInTable) {\n                                    whereQryAfterJoin[column] = whereQuery[column];\n                                }\n                        }\n                    }\n                    for (const column in whereQryAfterJoin) {\n                        delete whereQryParam[column];\n                    }\n                }\n                return {\n                    isWhereEmpty: getLength(whereQryParam) === 0,\n                    whereQryAfterJoin,\n                    whereQueryModified: whereQryParam\n                }\n            }\n            const removeJoinColumnResult = removeJoinColumn(whereQuery);\n            const whereQryAfterJoin = removeJoinColumnResult.whereQryAfterJoin;\n            query.where = removeJoinColumnResult.whereQueryModified;\n            if (removeJoinColumnResult.isWhereEmpty) {\n                delete query.where;\n            }\n            const joinQuery = this.joinQueryStack_[0];\n            Object.assign(joinQuery['whereJoin'], whereQryAfterJoin);\n        }\n\n        return this.executeSelect({\n            from: tableName,\n            where: query.where,\n            case: query.case,\n            flatten: query.flatten,\n            store: query.store,\n            meta: query.meta\n        }).then(results => {\n            this.results = results.map((item) => {\n                return {\n                    [this.currentQueryStackIndex_]: item\n                };\n            });\n            this.tablesFetched.push(\n                joinQueryStack[0].joinTableInfo.table1.table\n            );\n            return this.startExecutingJoinLogic_();\n        });\n    }\n\n    private onJoinQueryFinished_() {\n        if (this.results.length === 0) return;\n        const selectApi = this.select;\n        try {\n            let results = [];\n            const tables = getKeys(this.results[0]);\n            const tablesLength = tables.length;\n            this.results.forEach((result) => {\n                let data = result[\"0\"]; // first table data\n                for (let i = 1; i < tablesLength; i++) {\n                    data = { ...data, ...result[i] };\n                }\n                results.push(data);\n            });\n            selectApi['results'] = results;\n            selectApi.setLimitAndSkipEvaluationAtEnd_();\n            selectApi.query.flatten = null;\n            if (process.env.NODE_ENV !== 'production') {\n                try {\n                    selectApi.processOrderBy();\n                }\n                catch (ex) {\n                    return promiseReject(\n                        new LogHelper((ERROR_TYPE as IErrorType).InvalidOrderQuery, ex.message)\n                    );\n                }\n            }\n            else {\n                selectApi.processOrderBy();\n            }\n        }\n        catch (ex) {\n            return promiseReject(\n                new LogHelper(ERROR_TYPE.InvalidJoinQuery, ex.message)\n            );\n        }\n    }\n\n    private startExecutingJoinLogic_() {\n        const joinQuery = this.joinQueryStack_[this.currentQueryStackIndex_];\n        if (joinQuery) {\n            try {\n                let jointblInfo = joinQuery.joinTableInfo;\n                return this.executeSelect({\n                    from: joinQuery.with,\n                    where: joinQuery.where,\n                    case: joinQuery.case,\n                    flatten: joinQuery.flatten,\n                    store: joinQuery.store,\n                    meta: joinQuery.meta\n                }).then(results => {\n                    this.jointables(joinQuery, jointblInfo, results);\n                    this.tablesFetched.push(jointblInfo.table2.table);\n                    ++this.currentQueryStackIndex_;\n                    return this.startExecutingJoinLogic_();\n                });\n            }\n            catch (ex) {\n                return promiseReject(\n                    new LogHelper(ERROR_TYPE.InvalidJoinQuery, ex.message)\n                );\n            }\n        }\n        else {\n            return this.onJoinQueryFinished_();\n        }\n    }\n\n    private jointables(joinQuery: JoinQueryWithInfo, jointblInfo: JoinTableInfo, secondtableData: any[]) {\n        const joinType = joinQuery.type;\n        const output = [];\n        const column1 = jointblInfo.table1.column;\n        const column2 = jointblInfo.table2.column;\n        const table1Index = this.tablesFetched.indexOf(jointblInfo.table1.table);\n        const table2Index = this.currentQueryStackIndex_ + 1;\n        const asQuery = joinQuery.as;\n        const mapWithAlias = asQuery ? (value: object) => {\n            for (const key in asQuery) {\n                const asValue = asQuery[key];\n                if (value[asValue] === undefined) {\n                    value[asValue] = value[key];\n                    delete value[key];\n                }\n            }\n            return value;\n        } : (val) => val;\n\n        let index = 0;\n        let valueMatchedFromSecondTable: any[];\n        const whereQry = Object.assign({}, joinQuery['whereJoin']);\n        const whereCheker = new WhereChecker(whereQry, (getLength(whereQry) > 0));\n        let joinerComparer: (valueFromSecondTable, valueFromFirstTable) => boolean;\n\n        const performInnerJoin = () => {\n            joinerComparer = (valueFromSecondTable, valueFromFirstTable,) => {\n                return valueFromFirstTable[table1Index][column1] === valueFromSecondTable[column2];\n            }\n            defaultValueSetter = () => { };\n        };\n\n        let defaultValueSetter;\n        const performleftJoin = () => {\n            const columnDefaultValue = {};\n            const nullValue = null;\n            if (joinQuery.store) {\n                getKeys(joinQuery.store).forEach(columnName => {\n                    columnDefaultValue[columnName] = nullValue;\n                })\n            }\n            else {\n                this.getTable(jointblInfo.table2.table).columns.forEach(col => {\n                    columnDefaultValue[col.name] = nullValue;\n                });\n            }\n\n            if (table2Index === 1) {\n                joinerComparer = function (valueFromSecondTable, valueFromFirstTable) {\n                    return valueFromFirstTable[table1Index][column1] === valueFromSecondTable[column2];\n                };\n            }\n            else {\n                joinerComparer = function (valueFromSecondTable, valueFromFirstTable) {\n                    const value = valueFromFirstTable[table1Index];\n                    return value != null && value[column1] === valueFromSecondTable[column2];\n                };\n            }\n\n            defaultValueSetter = () => {\n                if (valueMatchedFromSecondTable.length === 0) {\n                    valueMatchedFromSecondTable = [columnDefaultValue];\n                }\n            }\n        };\n        switch (joinType) {\n            case \"left\":\n                performleftJoin(); break;\n            default:\n                performInnerJoin();\n        }\n        this.results.forEach((valueFromFirstTable) => {\n            valueMatchedFromSecondTable = [];\n            // perform left join\n            secondtableData.forEach(valueFromSecondTable => {\n                if (joinerComparer(valueFromSecondTable, valueFromFirstTable)) {\n                    valueMatchedFromSecondTable.push({\n                        ...valueFromSecondTable\n                    });\n                }\n            });\n\n            defaultValueSetter();\n\n            valueMatchedFromSecondTable.forEach(function (value) {\n                value = mapWithAlias(value);\n                if (!whereCheker.check(value)) return;\n\n                output[index] = { ...valueFromFirstTable };\n                output[index++][table2Index] = value;\n            });\n        });\n        this.results = output;\n    }\n\n    private getJoinTableInfo_(joinOn: string) {\n        joinOn = removeSpace(joinOn);\n        const splittedjoinOn = joinOn.split(\"=\");\n        const splittedjoinOnbydotFirst = splittedjoinOn[0].split(\".\");\n        const splittedjoinOnbydotSecond = splittedjoinOn[1].split(\".\");\n        const info = {\n            table1: {\n                table: splittedjoinOnbydotFirst[0],\n                column: splittedjoinOnbydotFirst[1]\n            },\n            table2: {\n                table: splittedjoinOnbydotSecond[0],\n                column: splittedjoinOnbydotSecond[1]\n            }\n        } as JoinTableInfo;\n        return info;\n    }\n\n    private checkJoinQuery_(jointblInfo: JoinTableInfo, qry: IJoinQuery) {\n        if (qry.store) return null;\n\n        const table1 = jointblInfo.table1;\n        const table2 = jointblInfo.table2;\n        const tableSchemaOf1stTable = this.getTable(table1.table);\n        const tableSchemaOf2ndTable = this.getTable(table2.table);\n        let err: LogHelper;\n        // check on info & with info \n        if (qry.with !== table2.table) {\n            err = new LogHelper(ERROR_TYPE.InvalidJoinQuery,\n                `on value should contains value of with`\n            );\n        }\n\n        // check for column existance\n        if (tableSchemaOf1stTable.columns.find(q => q.name === table1.column) == null) {\n            err = new LogHelper(ERROR_TYPE.InvalidJoinQuery,\n                `column ${table1.column} does not exist in table ${table1.table}`\n            );\n        }\n        else if (tableSchemaOf2ndTable.columns.find(q => q.name === table2.column) == null) {\n            err = new LogHelper(ERROR_TYPE.InvalidJoinQuery,\n                `column ${table2.column} does not exist in table ${table2.table}`\n            );\n        }\n\n        // check for column match in both table\n        if (qry.as == null) {\n            qry.as = {};\n        }\n        tableSchemaOf1stTable.columns.every(function (column) {\n            const columnFound = tableSchemaOf2ndTable.columns.find(q => q.name === column.name && q.name !== table1.column);\n            if (columnFound != null && qry.as[columnFound.name] == null) {\n                err = new LogHelper(ERROR_TYPE.InvalidJoinQuery,\n                    `column ${column.name} exist in both table ${table1.table} & ${table2.table}`\n                );\n                return false;\n            }\n            return true;\n        });\n        const whereQry = qry.where;\n        const whereJoin = {};\n        if (whereQry) {\n            for (const columnName in whereQry) {\n                switch (columnName) {\n                    case \"or\":\n                    case \"in\":\n                        break;\n                    default:\n                        const columnFound = tableSchemaOf2ndTable.columns.find(q => q.name === columnName);\n                        if (!columnFound) {\n                            whereJoin[columnName] = whereQry[columnName];\n                            delete whereQry[columnName];\n                        }\n                }\n            }\n            if (getLength(whereQry) === 0) {\n                qry.where = null;\n            }\n        }\n        qry['whereJoin'] = whereJoin;\n        return err;\n    }\n}\n\ntype JoinTableInfo = {\n    table1: { table: string, column: string }\n    table2: { table: string, column: string }\n};","import { promiseResolve } from \"@/common\";\nimport { getKeys } from \"../utils\";\n\nexport class MemoryObjectStore {\n    data: any[];\n\n    constructor(data: any[]) {\n        this.data = data;\n    }\n\n    get indexNames() {\n        const keys = getKeys(this.data[0])\n        return {\n            contains(columnName: string) {\n                return keys.indexOf(columnName) >= 0;\n            }\n        }\n    }\n\n    index(column: string) {\n        return {\n            openCursor: (keyRange?: IDBKeyRange) => {\n                const cursorRequest = {\n\n                } as {\n                    onsuccess: Function,\n                    onerror: Function\n                }\n                let index = 0;\n                const cursor = {\n                    continue() {\n                        ++index;\n                        execute();\n                    },\n                }\n                const callOnSuccess = (result) => {\n                    cursorRequest.onsuccess({\n                        target: {\n                            result\n                        }\n                    });\n                }\n                const execute = () => {\n                    const value = this.data[index];\n                    if (value) {\n                        const columnValue = value[column];\n                        if (columnValue && (keyRange == null || keyRange.includes(columnValue))) {\n                            (cursor as any).key = columnValue;\n                            (cursor as any).value = value;\n                            callOnSuccess(cursor)\n                        }\n                        else {\n                            cursor.continue();\n                        }\n                    }\n                    else {\n                        callOnSuccess(null);\n                    }\n                }\n                promiseResolve().then(execute);\n                return cursorRequest;\n            }\n        }\n    }\n}","import { ISelectQuery, QUERY_OPTION, IDB_MODE, API, IWhereQuery, promiseResolve, IOrderQuery } from \"@/common\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { QueryHelper } from \"@worker/executors/query_helper\";\nimport { isArray, isObject, getObjectFirstKey, promiseReject, getLength } from \"@/worker/utils\";\nimport { setPushResult, setLimitAndSkipEvaluationAtEnd, removeDuplicates } from \"./base_select\";\nimport { ThenEvaluator } from \"./then_evaluator\";\nimport { executeWhereUndefinedLogic } from \"./not_where\"\nimport { processAggregateQry, processGroupDistinctAggr, processOrderBy } from \"./order_by\";\nimport { executeAggregateGroupBy, processGroupBy } from \"./group_by\";\nimport { executeWhereLogic } from \"./where\";\nimport { BaseFetch } from \"@executors/base_fetch\";\nimport { executeInLogic } from \"./in\";\nimport { executeRegexLogic } from \"./regex\";\nimport { executeJoinQuery } from \"./join\";\nimport { MemoryObjectStore } from \"@/worker/memory_store\";\n\nexport class Select extends BaseFetch {\n    sorted = false;\n    isOr: boolean;\n    isArrayQry: boolean;\n    query: ISelectQuery;\n    orInfo: {\n        results?: any[];\n        orQuery: object\n    };\n\n    isSubQuery = false;\n\n    protected pushResult: (value) => void;\n\n    protected thenEvaluator = new ThenEvaluator();\n\n    executeWhereUndefinedLogic: typeof executeWhereUndefinedLogic;\n\n    setLimitAndSkipEvaluationAtEnd_: typeof setLimitAndSkipEvaluationAtEnd\n    setPushResult: typeof setPushResult;\n    removeDuplicates: typeof removeDuplicates;\n    executeJoinQuery: typeof executeJoinQuery\n    processGroupDistinctAggr: typeof processGroupDistinctAggr;\n    processOrderBy: typeof processOrderBy;\n    processAggregateQry: typeof processAggregateQry;\n    executeAggregateGroupBy: typeof executeAggregateGroupBy;\n    processGroupBy: typeof processGroupBy;\n\n\n    constructor(query: ISelectQuery, util: IDBUtil) {\n        super();\n        this.query = query;\n        this.util = util;\n        this.tableName = query.from;\n        this.setPushResult();\n        if (isArray(query.where)) {\n            this.isArrayQry = true;\n            this.setLimitAndSkipEvaluationAtEnd_();\n        }\n        else {\n            this.skipRecord = query.skip;\n            this.limitRecord = query.limit;\n        }\n        const orderQuery = query.order;\n        if (orderQuery) {\n            if (isArray(orderQuery) || (orderQuery as IOrderQuery).case || isObject((orderQuery as IOrderQuery).by)) {\n                ((orderQuery as IOrderQuery).idbSorting) = false;\n            }\n            this.setLimitAndSkipEvaluationAtEnd_();\n        }\n        else if (query.groupBy) {\n            this.setLimitAndSkipEvaluationAtEnd_();\n        }\n    }\n\n    execute(beforeExecute?: () => Promise<any>): Promise<any> {\n        let pResult: Promise<void>;\n        if (!beforeExecute) {\n            beforeExecute = () => promiseResolve(null);\n        }\n        const query = this.query;\n        try {\n            const err = new QueryHelper(this.db).validate(API.Select, query);\n            if (err) return promiseReject(err);\n            return beforeExecute().then(_ => {\n                this.initTransaction_();\n                if (query.join == null) {\n                    if (query.where != null) {\n                        if (isArray(query.where)) {\n                            pResult = this.processWhereArrayQry();\n                        }\n                        else {\n                            pResult = this.processWhere_();\n                        }\n                    }\n                    else {\n                        pResult = this.executeWhereUndefinedLogic();\n                    }\n                }\n                else {\n                    pResult = this.executeJoinQuery();\n                }\n                return pResult.then(\n                    this.returnResult_.bind(this)\n                )\n            })\n        }\n        catch (ex) {\n            return this.onException(ex);\n        }\n    }\n\n    private processWhereArrayQry() {\n        this.isArrayQry = true;\n        const whereQuery = this.query.where as IWhereQuery[];\n        const pKey = this.primaryKey();\n        let isFirstWhere = true, output = [], operation;\n\n        const isItemExist = (keyValue) => {\n            return output.findIndex(item => item[pKey] === keyValue) >= 0;\n        };\n        const onSuccess = () => {\n            if (operation === QUERY_OPTION.And) {\n                const doAnd = () => {\n                    let andResults = [];\n                    this.results.forEach((item) => {\n                        if (isItemExist(item[pKey])) {\n                            andResults.push(item);\n                        }\n                    });\n                    output = andResults;\n                    andResults = null;\n                };\n\n                if (isFirstWhere === true) {\n                    output = this.results;\n                }\n                else if (output.length > 0) {\n                    doAnd();\n                }\n            }\n            else {\n                if (output.length > 0) {\n                    this.results = [...output, ...this.results];\n                    this.removeDuplicates();\n                }\n                output = this.results;\n            }\n            isFirstWhere = false;\n            if (whereQuery.length > 0) {\n                this.results = [];\n                return processFirstQry();\n            }\n            else {\n                this.results = output;\n            }\n            return promiseResolve();\n        };\n        const executeWhere = (whereQuery): Promise<any> => {\n            const select = new Select({\n                from: this.query.from,\n                where: whereQuery as any\n            }, this.util);\n            return select.execute().then(results => {\n                this.results = results;\n                return onSuccess();\n            });\n        };\n        const processFirstQry = (): Promise<any> => {\n            let whereQueryToProcess = whereQuery.shift();\n            const whereQueryOr = whereQueryToProcess[QUERY_OPTION.Or];\n            if (whereQueryOr) {\n                if (isArray(whereQueryOr)) {\n                    operation = QUERY_OPTION.Or;\n                    return executeWhere(whereQueryOr);\n                }\n                if (getLength(whereQueryToProcess) === 1) {\n                    operation = QUERY_OPTION.Or;\n                    whereQueryToProcess = whereQueryOr as any;\n                }\n                else {\n                    operation = QUERY_OPTION.And;\n                }\n            }\n            else {\n                operation = QUERY_OPTION.And;\n                if (isArray(whereQueryToProcess)) {\n                    return executeWhere(whereQueryToProcess);\n                }\n            }\n            this.query.where = whereQueryToProcess;\n            return this.processWhere_().then(onSuccess);\n        };\n        return processFirstQry();\n    }\n\n    private initTransaction_() {\n        const store = this.query.store\n        if (store) {\n            this.objectStore = new MemoryObjectStore(store as any[]) as any;\n            return\n        }\n        if (!this.isTxQuery) {\n            this.util.createTransactionIfNotExist([this.tableName], IDB_MODE.ReadOnly);\n        }\n        this.objectStore = this.util.objectStore(this.tableName);\n    }\n\n    private processWhere_() {\n        this.shouldAddValue = (cursor: IDBCursorWithValue) => {\n            const cursorValue = cursor.value;\n            const that = this;\n            const proxy = new Proxy(cursorValue, {\n                get(target, p, receiver) {\n                    let val = cursorValue[p];\n                    if (!val) {\n                        const column = that.getColumnInfo(p as string);\n                        if (column && column.keyPath) {\n                            return column.keyPath.map(col => {\n                                return cursorValue[col];\n                            });\n                        }\n                    }\n                    return val;\n                },\n            });\n            return this.whereChecker.check(proxy);\n        };\n        if ((this.query.where as IWhereQuery).or) {\n            this.processOrLogic_();\n        }\n        return this.goToWhereLogic().then(() => {\n            return this.onWhereEvaluated();\n        })\n    }\n\n    private onWhereEvaluated() {\n        if (this.isOr) {\n            return this.orQuerySuccess_();\n        }\n    }\n\n    private returnResult_ = () => {\n        if (this.results.length > 0) {\n            const query = this.query;\n            if (query.flatten) {\n                const flattendData = [];\n                const indexToDelete = new Map<number, Boolean>();\n                query.flatten.forEach(column => {\n                    this.results.forEach((data, i) => {\n                        data[column].forEach(item => {\n                            flattendData.push(\n                                { ...data, ...{ [column]: item } }\n                            );\n                        });\n                        indexToDelete.set(i, true);\n                    });\n                });\n                let itemsDeleted = 0;\n                indexToDelete.forEach((_, key) => {\n                    this.results.splice(key - itemsDeleted, 1);\n                    ++itemsDeleted;\n                });\n                this.results = this.results.concat(flattendData);\n            }\n            this.processGroupDistinctAggr();\n            this.processOrderBy();\n            if (this.skipAtEnd) {\n                this.results.splice(0, query.skip);\n            }\n            if (this.limitAtEnd) {\n                this.results = this.results.slice(0, query.limit);\n            }\n        }\n        return this.results;\n    }\n\n    private orQueryFinish_() {\n        this.isOr = false;\n        this.results = this.orInfo.results;\n        // free or info memory\n        this.orInfo = null;\n        this.removeDuplicates();\n        // this.onQueryFinished();\n    }\n\n    private orQuerySuccess_() {\n        const query = this.query;\n        if (this.results.length > 0) {\n            this.orInfo.results = [... this.orInfo.results, ...this.results];\n        }\n\n        this.results = [];\n        const key = getObjectFirstKey(this.orInfo.orQuery);\n        if (key != null) {\n            const where = {};\n            where[key] = this.orInfo.orQuery[key];\n            delete this.orInfo.orQuery[key];\n            query.where = where;\n            return this.goToWhereLogic().then(this.onWhereEvaluated.bind(this))\n        }\n        return this.orQueryFinish_();\n    }\n\n    private processOrLogic_() {\n        this.isOr = true;\n        const where = this.query.where as IWhereQuery;\n        this.orInfo = {\n            orQuery: where.or as any,\n            results: []\n        };\n        this.setLimitAndSkipEvaluationAtEnd_();\n        // free or memory\n        delete where.or;\n    }\n}\n\nSelect.prototype.executeInLogic = executeInLogic;\nSelect.prototype.executeWhereUndefinedLogic = executeWhereUndefinedLogic;\nSelect.prototype.executeWhereLogic = executeWhereLogic;\nSelect.prototype.executeRegexLogic = executeRegexLogic;\n\nSelect.prototype.setLimitAndSkipEvaluationAtEnd_ = setLimitAndSkipEvaluationAtEnd\nSelect.prototype.setPushResult = setPushResult;\nSelect.prototype.removeDuplicates = removeDuplicates;\nSelect.prototype.executeJoinQuery = executeJoinQuery\nSelect.prototype.processGroupDistinctAggr = processGroupDistinctAggr;\nSelect.prototype.processOrderBy = processOrderBy;\nSelect.prototype.processAggregateQry = processAggregateQry;\nSelect.prototype.executeAggregateGroupBy = executeAggregateGroupBy;\nSelect.prototype.processGroupBy = processGroupBy;\n","export const isObject = (value) => {\n    return typeof value === 'object';\n};","import { Select } from \"./\";\nimport { promise, promiseAll } from \"@/common\";\nimport { BaseFetch } from \"../base_fetch\";\nimport { executeLimitForWhere_, executeSimpleForWhere_, getCursorOnSuccess } from \"./where\";\nimport { executeSkipAndLimitForWhere_, executeSkipForWhere_ } from \"./regex\";\n\nexport const executeInLogic = function (this: BaseFetch, column, values) {\n    let skip = this.skipRecord;\n    const skipOrPush = (val) => {\n        if (skip === 0) {\n            (this as Select)['pushResult'](val);\n        }\n        else {\n            --skip;\n        }\n    };\n    const onSuccess = getCursorOnSuccess.call(\n        this,\n        executeSimpleForWhere_,\n        executeLimitForWhere_,\n        executeSkipForWhere_,\n        executeSkipAndLimitForWhere_\n    );\n\n    const runInLogic: (val) => Promise<void> = (value) => {\n        return promise((res, rej) => {\n            const cursorRequest = this.objectStore.index(column).openCursor(\n                this.util.keyRange(value)\n            );\n            cursorRequest.onsuccess = onSuccess.call(this, res, skipOrPush);\n            cursorRequest.onerror = rej;\n        });\n    };\n\n    return promiseAll<void>(\n        values.map(runInLogic)\n    );\n\n};\n","import { Select } from \"./index\";\n\nexport const setPushResult = function (this: Select) {\n    const caseQuery = this.query.case;\n    if (caseQuery) {\n        this.pushResult = (value) => {\n            let columnName: string;\n            this.thenEvaluator.setCaseAndValue(caseQuery, value);\n            for (columnName in caseQuery) {\n                value[columnName] = this.thenEvaluator.setColumn(columnName).evaluate();\n            }\n            this.results.push(value);\n        };\n    }\n    else {\n        this.pushResult = (value) => {\n            this.results.push(value);\n        };\n    }\n}\n\nexport const setLimitAndSkipEvaluationAtEnd = function (this: Select) {\n    if (this.query.limit) {\n        this.limitAtEnd = true;\n    }\n    if (this.query.skip) {\n        this.skipAtEnd = true;\n    }\n}\n\nexport const removeDuplicates = function (this: Select) {\n    let datas = this.results;\n    const key = this.primaryKey();\n    const lookupObject = new Map();\n    for (let i = 0, len = datas.length; i < len; i++) {\n        lookupObject.set(datas[i][key], datas[i]);\n    }\n\n    this.results = Array.from(lookupObject.values());\n}","import { Select } from \".\";\nimport { getDataType, getObjectFirstKey } from \"@/worker/utils\";\nimport { QUERY_OPTION, DATA_TYPE } from \"@/common\";\n\nexport const processGroupBy = function (this: Select) {\n    const groupBy = this.query.groupBy as any;\n    let datas = this.results;\n    const lookUpObj = new Map<string, any>();\n\n    const groupByDataType = getDataType(groupBy);\n    if (groupByDataType !== DATA_TYPE.Object) {\n        if (groupByDataType === DATA_TYPE.String) {\n            for (const i in datas) {\n                lookUpObj.set(datas[i][groupBy as string], datas[i]);\n            }\n        }\n        else {\n            let objKey;\n            for (const i in datas) {\n                objKey = \"\";\n                for (const column in groupBy) {\n                    objKey += datas[i][groupBy[column]];\n                }\n                lookUpObj.set(objKey, datas[i]);\n            }\n        }\n    }\n    else {\n        const caseQueryLength = Object.keys(groupBy).length;\n        if (caseQueryLength === 1) {\n            const groupByColumn = getObjectFirstKey(groupBy);\n            this.thenEvaluator.setCaseAndColumn(groupBy, groupByColumn);\n            for (const i in datas) {\n                lookUpObj.set(this.thenEvaluator.setValue(datas[i]).evaluate(), datas[i]);\n            }\n        }\n        else {\n            let objKey;\n            for (const i in datas) {\n                objKey = \"\";\n                this.thenEvaluator.setCaseAndValue(groupBy, datas[i]);\n                for (const column in groupBy) {\n                    objKey += this.thenEvaluator.setColumn(column).evaluate();\n                }\n                lookUpObj.set(objKey, datas[i]);\n            }\n        }\n    }\n\n    this.results = Array.from(lookUpObj.values());\n}\n\nexport const executeAggregateGroupBy = function (this: Select) {\n    const grpQry = this.query.groupBy as any;\n    let datas = this.results;\n\n    const lookUpObj = new Map<string, any>();\n    // assign aggregate\n    const aggregateQry = this.query.aggregate;\n\n    let index;\n    let objKey;\n    let value;\n    let columnToAggregate;\n    const calculateAggregate = () => {\n        const getCount = () => {\n            value = lookUpObj.get(objKey);\n            // get old value\n            value = value ? value[\"count(\" + columnToAggregate + \")\"] : 0;\n            // add with old value if data exist\n            value += datas[index][columnToAggregate] ? 1 : 0;\n            return value;\n        };\n        const getList = () => {\n            value = lookUpObj.get(objKey);\n            // get old value\n            value = value ? value[\"list(\" + columnToAggregate + \")\"] : [];\n            // push value\n            value.push(datas[index][columnToAggregate]);\n            return value;\n        };\n        const getMax = () => {\n            value = lookUpObj.get(objKey);\n            // get old value\n            value = value ? value[\"max(\" + columnToAggregate + \")\"] : 0;\n            datas[index][columnToAggregate] = datas[index][columnToAggregate] ?\n                datas[index][columnToAggregate] : 0;\n            // compare between old value and new value\n            return value > datas[index][columnToAggregate] ? value : datas[index][columnToAggregate];\n        };\n        const getMin = () => {\n            value = lookUpObj.get(objKey);\n            // get old value\n            value = value ? value[\"min(\" + columnToAggregate + \")\"] : Infinity;\n            datas[index][columnToAggregate] = datas[index][columnToAggregate] ?\n                datas[index][columnToAggregate] : Infinity;\n            // compare between old value and new value\n            return value < datas[index][columnToAggregate] ? value : datas[index][columnToAggregate];\n        };\n        const getSum = () => {\n            value = lookUpObj.get(objKey);\n            // get old value\n            value = value ? value[\"sum(\" + columnToAggregate + \")\"] : 0;\n            // add with old value if data exist\n            value += datas[index][columnToAggregate] ? datas[index][columnToAggregate] : 0;\n            return value;\n        };\n        const getAvg = () => {\n            value = lookUpObj.get(objKey)\n            // get old sum value\n            let sumOfColumn = value ? value[\"sum(\" + columnToAggregate + \")\"] : 0;\n            // add with old value if data exist\n            sumOfColumn += datas[index][columnToAggregate] ? datas[index][columnToAggregate] : 0;\n            datas[index][\"sum(\" + columnToAggregate + \")\"] = sumOfColumn;\n            // get old count value\n            value = value ? value[\"count(\" + columnToAggregate + \")\"] : 0;\n            // add with old value if data exist\n            value += datas[index][columnToAggregate] ? 1 : 0;\n            datas[index][\"count(\" + columnToAggregate + \")\"] = value;\n        };\n        for (const prop in aggregateQry) {\n            const aggregateColumn = aggregateQry[prop];\n            const aggregateValType = getDataType(aggregateColumn);\n            let aggregateCalculator;\n            switch (prop) {\n                case QUERY_OPTION.Count:\n                    aggregateCalculator = getCount;\n                    break;\n                case QUERY_OPTION.Max:\n                    aggregateCalculator = getMax;\n                    break;\n                case QUERY_OPTION.Min:\n                    aggregateCalculator = getMin;\n                    break;\n                case QUERY_OPTION.Sum:\n                    aggregateCalculator = getSum;\n                    break;\n                case QUERY_OPTION.Avg:\n                    aggregateCalculator = getAvg;\n                    break;\n                case QUERY_OPTION.List:\n                    aggregateCalculator = getList;\n                    break;\n            }\n            switch (aggregateValType) {\n                case DATA_TYPE.String:\n                    columnToAggregate = aggregateColumn;\n                    datas[index][`${prop}(${columnToAggregate})`] = aggregateCalculator();\n                    break;\n                case DATA_TYPE.Array:\n                    for (const item in aggregateColumn) {\n                        columnToAggregate = aggregateColumn[item];\n                        datas[index][`${prop}(${columnToAggregate})`] = aggregateCalculator();\n                    }\n            }\n        }\n    };\n\n    if (getDataType(grpQry) === DATA_TYPE.String) {\n        for (index in datas) {\n            objKey = datas[index][grpQry];\n            calculateAggregate();\n            lookUpObj.set(objKey, datas[index]);\n        }\n    }\n    else {\n        for (index in datas) {\n            objKey = \"\";\n            for (const column in grpQry) {\n                objKey += datas[index][grpQry[column]];\n            }\n            calculateAggregate();\n            lookUpObj.set(objKey, datas[index]);\n        }\n\n    }\n    datas = Array.from(lookUpObj.values());\n\n    // Checking for avg and if exist then fill the datas;\n    const avgQuery = aggregateQry.avg;\n    if (avgQuery) {\n        if (getDataType(avgQuery) === DATA_TYPE.String) {\n            for (index in datas) {\n                const sumForAvg = datas[index][\"sum(\" + avgQuery + \")\"],\n                    countForAvg = datas[index][\"count(\" + avgQuery + \")\"];\n                datas[index][\"avg(\" + avgQuery + \")\"] = sumForAvg / countForAvg;\n                if (aggregateQry.count !== avgQuery) {\n                    delete datas[index][\"count(\" + avgQuery + \")\"];\n                }\n                if (aggregateQry.sum !== avgQuery) {\n                    delete datas[index][\"sum(\" + avgQuery + \")\"];\n                }\n            }\n        }\n        else {\n            const isCountTypeString = getDataType(aggregateQry.count) === DATA_TYPE.String;\n            const isSumTypeString = getDataType(aggregateQry.sum) === DATA_TYPE.String;\n            for (index in datas) {\n                for (const column in avgQuery as any) {\n                    const avgColumn = avgQuery[column],\n                        sum = datas[index][\"sum(\" + avgColumn + \")\"],\n                        count = datas[index][\"count(\" + avgColumn + \")\"];\n                    datas[index][\"avg(\" + avgColumn + \")\"] = sum / count;\n\n                    if (isCountTypeString) {\n                        if (aggregateQry.count !== avgColumn) {\n                            delete datas[index][\"count(\" + avgColumn + \")\"];\n                        }\n                        else if (aggregateQry.count.indexOf(avgColumn) === -1) {\n                            delete datas[index][\"count(\" + avgColumn + \")\"];\n                        }\n                    }\n\n                    if (isSumTypeString) {\n                        if (aggregateQry.sum !== avgColumn) {\n                            delete datas[index][\"sum(\" + avgColumn + \")\"];\n                        }\n                        else if (aggregateQry.sum.indexOf(avgColumn) === -1) {\n                            delete datas[index][\"sum(\" + avgColumn + \")\"];\n                        }\n                    }\n                }\n            }\n        }\n    }\n    this.results = datas;\n}\n","import { promise } from \"@/common\";\nimport { BaseFetch } from \"../base_fetch\";\nimport { Count } from \".\";\n\nexport const executeWhereUndefinedLogic = function (this: BaseFetch) {\n    let countRequest;\n    const objectStore = this.objectStore;\n    const onSuccess = (() => {\n        if (objectStore.count) {\n            countRequest = objectStore.count();\n            return (onFinish) => {\n                return () => {\n                    (this as Count).resultCount = countRequest.result;\n                    onFinish();\n                }\n            }\n        }\n        else {\n            let cursor;\n            countRequest = objectStore.openCursor();\n            return (onFinish) => {\n                return (e: any) => {\n                    cursor = e.target.result;\n                    if (cursor) {\n                        ++(this as Count).resultCount;\n                        cursor.continue();\n                    }\n                    else {\n                        onFinish();\n                    }\n                };\n            };\n        }\n    })();\n    return promise((res, rej) => {\n        countRequest.onerror = rej;\n        countRequest.onsuccess = onSuccess(res);\n    });\n}\n","import { BaseFetch } from \"../base_fetch\";\nimport { getLength } from \"@/worker/utils\";\nimport { Count } from \".\";\nimport { promise } from \"@/common\";\n\nexport const onWhereCount = function (this: BaseFetch, onFinish) {\n    return (e) => {\n        const cursor = e.target.result;\n        if (cursor) {\n            if (this.shouldAddValue(cursor)) {\n                ++(this as Count).resultCount;\n            }\n            cursor.continue();\n        }\n        else {\n            onFinish();\n        }\n    }\n}\n\nexport const executeWhereLogic = function (this: BaseFetch, column, value, op) {\n    value = op ? value[op] : value;\n    let cursorRequest;\n\n    const isWhereKeysLengthOne = getLength(this.query.where) === 1;\n    const objectStore = this.objectStore;\n\n    return promise((res, rej) => {\n        if (isWhereKeysLengthOne && objectStore.count) {\n            cursorRequest = objectStore.index(column).count(this.util.keyRange(value, op));\n            cursorRequest.onsuccess = () => {\n                (this as Count).resultCount = cursorRequest.result;\n                res();\n            }\n        }\n        else {\n            cursorRequest = objectStore.index(column).openCursor(this.util.keyRange(value, op));\n            cursorRequest.onsuccess = onWhereCount.call(this, res);\n        }\n        cursorRequest.onerror = rej;\n    });\n}","import { BaseFetch } from \"@executors/base_fetch\";\nimport { Select } from \"@executors/select\";\nimport { ICountQuery, ISelectQuery, IDB_MODE, API, IWhereQuery } from \"@/common\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { QueryHelper } from \"@executors/query_helper\";\nimport { promiseReject, isArray } from \"@worker/utils\";\nimport { executeWhereUndefinedLogic } from \"@executors/count/not_where\";\nimport { executeWhereLogic } from \"./where\";\nimport { executeRegexLogic } from \"./regex\";\nimport { executeInLogic } from \"./in\";\n\nexport class Count extends BaseFetch {\n\n    query: ICountQuery;\n    resultCount: number = 0;\n    executeWhereUndefinedLogic: typeof executeWhereUndefinedLogic;\n\n    constructor(query: ICountQuery, util: IDBUtil) {\n        super();\n        this.query = query;\n        this.util = util;\n        this.tableName = query.from;\n    }\n\n    execute(beforeExecute: () => Promise<any>) {\n        const queryHelper = new QueryHelper(this.db);\n        const query = this.query;\n        const err = queryHelper.validate(API.Count, query);\n        if (err) {\n            return promiseReject(\n                err\n            );\n        }\n        return beforeExecute().then(_ => {\n            let result: Promise<void>;\n            try {\n                const getDataFromSelect = () => {\n                    const selectInstance = new Select(query as ISelectQuery, this.util);\n                    selectInstance.isTxQuery = this.isTxQuery;\n                    return selectInstance.execute().then(results => {\n                        this.resultCount = results.length;\n                    });\n                };\n                this.initTransaction_();\n                if (query.join == null) {\n                    if (query.where != null) {\n                        if ((query.where as IWhereQuery).or || isArray(query.where)) {\n                            result = getDataFromSelect();\n                        }\n                        else {\n                            this.shouldAddValue = (cursor) => {\n                                return this.whereChecker.check(cursor.value);\n                            };\n                            result = this.goToWhereLogic();\n                        }\n                    }\n                    else {\n                        result = this.executeWhereUndefinedLogic() as any;\n                    }\n                }\n                else {\n                    result = getDataFromSelect();\n                }\n            }\n            catch (ex) {\n                this.onException(ex);\n            }\n            return result.then(_ => {\n                return this.resultCount;\n            })\n        });\n    }\n\n    private initTransaction_() {\n        const tableName = this.query.from;\n        if (!this.isTxQuery) {\n            this.util.createTransaction([tableName], IDB_MODE.ReadOnly);\n        }\n        this.objectStore = this.util.objectStore(tableName);\n    }\n}\n\nCount.prototype.executeWhereUndefinedLogic = executeWhereUndefinedLogic;\nCount.prototype.executeWhereLogic = executeWhereLogic\nCount.prototype.executeRegexLogic = executeRegexLogic\nCount.prototype.executeInLogic = executeInLogic","import { BaseFetch } from \"../base_fetch\";\nimport { promise } from \"@/common\";\nimport { onWhereCount } from \"./where\";\n\nexport const executeRegexLogic = function (this: BaseFetch, column: string, exp: RegExp) {\n    const cursorRequest = this.objectStore.index(column).openCursor();\n    this.shouldAddValue = (cursor) => {\n        return exp.test(cursor.key) &&\n            this.whereChecker.check(cursor.value);\n    };\n    return promise((res, rej) => {\n        cursorRequest.onerror = rej;\n        cursorRequest.onsuccess = onWhereCount.call(this, res);\n    })\n}","import { promise, promiseAll } from \"@/common\";\nimport { getLength } from \"@/worker/utils\";\nimport { BaseFetch } from \"../base_fetch\";\nimport { onWhereCount } from \"./where\";\n\n\nexport const executeInLogic = function (this: BaseFetch, column, values) {\n    const objectStore = this.objectStore;\n    const columnStore = objectStore.index(column);\n    const isWhereKeysLengthOne = getLength(this.query.where) === 1;\n\n    const runInLogic: (val) => Promise<void> = (value) => {\n        const keyRange = this.util.keyRange(value);\n        if (isWhereKeysLengthOne && objectStore.count) {\n            return promise((res, rej) => {\n                const cursorRequest = columnStore.count(keyRange);\n                cursorRequest.onsuccess = (e: any) => {\n                    this.resultCount += e.target.result;\n                    res();\n                };\n                cursorRequest.onerror = rej;\n            });\n        }\n        return promise<void>((res, rej) => {\n            const cursorRequest = columnStore.openCursor(keyRange);\n            cursorRequest.onsuccess = onWhereCount.call(this, res);\n            cursorRequest.onerror = rej;\n        });\n    };\n\n    return promiseAll<void>(\n        values.map(function (val) {\n            return runInLogic(val);\n        })\n    );\n}\n","import { isArray } from \"./is_array\";\n\nexport const variableFromPath = (path: string) => {\n    const properties: string[] = isArray(path) ? path as any : path.split(\".\");\n    return properties.reduce((prev, curr) => prev && prev[curr], self);\n}","import { getDataType, variableFromPath, promiseReject, LogHelper } from \"@worker/utils\";\nimport { DATA_TYPE, ERROR_TYPE, IUpdateQuery } from \"@/common\";\n\nexport const updateValue = (query: IUpdateQuery, storedValue) => {\n    let setValue = query.set;\n    const mapSet = query.mapSet;\n    if (mapSet) {\n        const result = (mapSet as Function)(setValue, storedValue);\n        if (result != null) {\n            setValue = result;\n        }\n    }\n    for (const key in setValue) {\n        const columnSetValue = setValue[key];\n        if (getDataType(columnSetValue) !== DATA_TYPE.Object) {\n            storedValue[key] = columnSetValue;\n        }\n        else {\n            for (const op in columnSetValue) {\n                let value = columnSetValue[op];\n                switch (op as any) {\n                    case '+': storedValue[key] += value; break;\n                    case '-': storedValue[key] -= value; break;\n                    case '*': storedValue[key] *= value; break;\n                    case '/': storedValue[key] /= value; break;\n                    case '{push}': storedValue[key].push(value); break;\n                    default: storedValue[key] = columnSetValue;\n                }\n                break;\n            }\n        }\n    }\n    return storedValue;\n};","import { IUpdateQuery, ISelectQuery, QUERY_OPTION, API, IWhereQuery, DATA_TYPE, ERROR_TYPE } from \"@/common\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { DbMeta } from \"@worker/model\";\nimport { QueryHelper } from \"../query_helper\";\nimport { promiseReject, isArray, getDataType, variableFromPath, LogHelper } from \"@worker/utils\";\nimport { BaseFetch } from \"@executors/base_fetch\";\nimport { Select } from \"@executors/select\";\nimport { executeWhereUndefinedLogic } from \"./not_where\";\nimport { executeInLogic } from \"./in\";\nimport { executeRegexLogic } from \"./regex\";\nimport { executeWhereLogic } from \"./where\";\n\nexport class Update extends BaseFetch {\n    executeWhereUndefinedLogic: typeof executeWhereUndefinedLogic\n\n    constructor(query: IUpdateQuery, util: IDBUtil) {\n        super();\n        this.query = query as any;\n        this.util = util;\n        this.tableName = query.in;\n        const mapSet = query.mapSet;\n        if (mapSet) {\n            const method = getDataType(mapSet) === DATA_TYPE.String ?\n                variableFromPath(mapSet as string) : mapSet;\n            if (!method) {\n                throw new LogHelper(ERROR_TYPE.MethodNotExist, mapSet);\n            }\n            query.mapSet = method;\n        }\n\n    }\n\n    execute(beforeExecute: () => Promise<any>) {\n        const query: IUpdateQuery = this.query as any;\n        try {\n            const queryHelper = new QueryHelper(this.db);\n            const err = queryHelper.validate(API.Update, query);\n            if (err) return promiseReject(err);\n            return beforeExecute().then(_ => {\n                this.initTransaction();\n                let pResult: Promise<void>;\n                if (query.where != null) {\n                    if ((query.where as IWhereQuery).or || isArray(query.where)) {\n                        pResult = this.executeComplexLogic_();\n                    }\n                    else {\n                        pResult = this.goToWhereLogic();\n                    }\n                }\n                else {\n                    pResult = this.executeWhereUndefinedLogic();\n                }\n                return pResult.then(() => {\n                    return this.rowAffected;\n                })\n            })\n        }\n        catch (ex) {\n            return this.onException(ex);\n        }\n    }\n\n    private executeComplexLogic_() {\n        const query: IUpdateQuery = this.query as any;\n        const selectObject = new Select({\n            from: query.in,\n            where: query.where,\n            ignoreCase: query.ignoreCase\n        } as ISelectQuery, this.util);\n        selectObject.isTxQuery = this.isTxQuery;\n        return selectObject.execute().then((results: any[]) => {\n            const key = this.primaryKey(query.in);\n            const inQuery = [];\n            results.forEach((value) => {\n                inQuery.push(value[key]);\n            });\n            results = null;\n            const whereQry = { [key]: { [QUERY_OPTION.In]: inQuery } };\n            this.query.where = whereQry;\n            this.initTransaction();\n            return this.goToWhereLogic();\n        });\n    }\n\n    private initTransaction() {\n        const tableName = (this.query as any).in;\n        if (!this.isTxQuery) {\n            this.util.createTransaction([tableName]);\n        }\n        this.objectStore = this.util.objectStore(tableName);\n    }\n}\n\nUpdate.prototype.executeWhereUndefinedLogic = executeWhereUndefinedLogic;\nUpdate.prototype.executeWhereLogic = executeWhereLogic\nUpdate.prototype.executeRegexLogic = executeRegexLogic\nUpdate.prototype.executeInLogic = executeInLogic","import { Update } from \"./\";\nimport { promise } from \"@/common\";\nimport { updateValue } from \"./update_value\";\n\n\nexport const executeWhereUndefinedLogic = function (this: Update) {\n    const cursorRequest: IDBRequest<IDBCursorWithValue> = this.objectStore.openCursor();\n    return promise<void>((res, rej) => {\n        cursorRequest.onsuccess = (e: any) => {\n            const cursor: IDBCursorWithValue = (e as any).target.result;\n            if (cursor) {\n                try {\n                    const cursorUpdateRequest = cursor.update(updateValue(this.query as any, cursor.value));\n                    cursorUpdateRequest.onsuccess = () => {\n                        ++this.rowAffected;\n                        cursor.continue();\n                    };\n                    cursorUpdateRequest.onerror = rej;\n                } catch (ex) {\n                    rej(\n                        ex\n                    );\n                }\n            }\n            else {\n                res();\n            }\n        };\n        cursorRequest.onerror = rej;\n    })\n\n}\n","import { promise, IUpdateQuery } from \"@/common\";\nimport { updateValue } from \"./update_value\";\nimport { Update } from \"./\";\n\nexport const executeWhereLogic = function (this: Update, column, value, op) {\n    const query: IUpdateQuery = this.query as any;\n    value = op ? value[op] : value;\n    const cursorRequest = this.objectStore.index(column).openCursor(this.util.keyRange(value, op));\n    return promise<void>((res, rej) => {\n        cursorRequest.onsuccess = (e: any) => {\n            const cursor: IDBCursorWithValue = e.target.result;\n            if (cursor) {\n                if (this.whereChecker.check(cursor.value)) {\n                    try {\n                        const cursorUpdateRequest = cursor.update(updateValue(query, cursor.value));\n                        cursorUpdateRequest.onsuccess = () => {\n                            ++this.rowAffected;\n                            cursor.continue();\n                        };\n                        cursorUpdateRequest.onerror = rej;\n                    } catch (ex) {\n                        rej(\n                            ex\n                        );\n                    }\n                }\n                else {\n                    cursor.continue();\n                }\n            }\n            else {\n                res();\n            }\n        };\n        cursorRequest.onerror = rej\n    })\n}","import { Update } from \"./\";\nimport { updateValue } from \"./update_value\";\nimport { promise } from \"@/common\";\n\nexport const executeRegexLogic = function (this: Update, column: string, exp: RegExp) {\n    let cursor: IDBCursorWithValue;\n    const cursorOpenRequest = this.objectStore.index(column).openCursor();\n    this.shouldAddValue = (cursor) => {\n        return exp.test(cursor.key) &&\n            this.whereChecker.check(cursor.value);\n    };\n    return promise<void>((res, rej) => {\n\n        cursorOpenRequest.onsuccess = (e: any) => {\n            cursor = e.target.result;\n            if (cursor) {\n                if (this.shouldAddValue(cursor)) {\n                    try {\n                        const cursorUpdateRequest = cursor.update(updateValue(this.query as any, cursor.value));\n                        cursorUpdateRequest.onsuccess = () => {\n                            ++this.rowAffected;\n                            cursor.continue();\n                        };\n                        cursorUpdateRequest.onerror = rej;\n                    } catch (ex) {\n                        rej(\n                            ex\n                        );\n                    }\n                }\n                else {\n                    cursor.continue();\n                }\n\n            }\n            else {\n                res();\n            }\n        };\n        cursorOpenRequest.onerror = rej;\n    })\n\n}\n","import { Update } from \"./\";\nimport { promiseAll, promise, IUpdateQuery } from \"@/common\";\nimport { updateValue } from \"./update_value\";\n\n\nexport const executeInLogic = function (this: Update, column, values: any[]) {\n    const columnStore = this.objectStore.index(column);\n    const query: IUpdateQuery = this.query as any;\n    const runInLogic: (val) => Promise<void> = (value) => {\n        return promise((res, rej) => {\n            const cursorRequest = columnStore.openCursor(this.util.keyRange(value));\n            cursorRequest.onsuccess = (e: any) => {\n                const cursor: IDBCursorWithValue = e.target.result;\n                if (cursor) {\n                    const value = cursor.value;\n                    if (this.whereChecker.check(value)) {\n                        try {\n                            const cursorUpdateRequest = cursor.update(updateValue(query, value));\n                            cursorUpdateRequest.onsuccess = () => {\n                                ++this.rowAffected;\n                                cursor.continue();\n                            };\n                            cursorUpdateRequest.onerror = rej;\n                        }\n                        catch (ex) {\n                            rej(\n                                ex\n                            );\n                        }\n\n                    }\n                    else {\n                        cursor.continue();\n                    }\n                }\n                else {\n                    res();\n                }\n            };\n            cursorRequest.onerror = rej;\n        });\n    };\n\n    return promiseAll<void>(\n        values.map(function (val) {\n            return runInLogic(val);\n        })\n    );\n}\n","import { IIntersectQuery, ISelectQuery } from \"@/common\";\nimport { Base } from \"@executors/base\";\nimport { Select } from \"@executors/select\";\n\nexport class Intersect extends Base {\n\n    constructor(intersectQry: IIntersectQuery, util) {\n        super();\n        this.query = intersectQry as any;\n        this.util = util;\n    }\n\n    execute() {\n        const intersectQry: IIntersectQuery = this.query as any;\n        let index = 0;\n        let hashMap = {};\n        let hashMapTemp = {};\n        let isQueryForSameTable = true;\n        const queries = intersectQry.queries;\n        const queryLength = queries.length;\n        queries.every((qry, i) => {\n            if (i + 1 < queryLength && qry.from !== queries[i + 1].from) {\n                isQueryForSameTable = false;\n                return false;\n            }\n            return true;\n        });\n        let getHashKey;\n        if (isQueryForSameTable) {\n            const pKey = this.primaryKey(queries[0].from);\n            getHashKey = (val) => {\n                return val[pKey];\n            };\n        }\n        else {\n            getHashKey = (val) => {\n                let columnValKey = \"\";\n                for (const key in val) {\n                    columnValKey += val[key];\n                }\n                return columnValKey;\n            };\n        }\n\n        let select: Select;\n        const fetchData = () => {\n            if (index < queryLength) {\n                select = new Select(queries[index], this.util);\n                return select.execute().then((selectResult) => {\n                    hashMap = {};\n                    selectResult.forEach(val => {\n                        const columnValKey = getHashKey(val);\n                        if (index === 0) {\n                            hashMapTemp[columnValKey] = val;\n                        } else if (hashMapTemp[columnValKey] != null) {\n                            hashMap[columnValKey] = val;\n                        }\n                    });\n                    if (index > 0) {\n                        hashMapTemp = { ...hashMap };\n                    }\n\n                    ++index;\n                    return fetchData();\n                })\n            }\n            else {\n                const results = [];\n                let resultPusher: (key: string) => void;\n                let skip = intersectQry.skip;\n                const limit = intersectQry.limit;\n                const onFinished = () => {\n                    select['results'] = results;\n                    Object.assign(select.query, {\n                        order: intersectQry.order,\n                        join: {} as any\n                    } as ISelectQuery);\n                    select.processOrderBy();\n                    select.processGroupDistinctAggr();\n                    return (select['results']);\n                };\n                let shouldStopLoop = false;\n                let key: string;\n                const pushResult = () => {\n                    results.push(hashMap[key]);\n                };\n                const checkLimitAndPush = () => {\n                    if (results.length < limit) {\n                        pushResult();\n                    }\n                    else {\n                        shouldStopLoop = true;\n                    }\n                };\n                const skipChecker = (callBack: () => void) => {\n                    if (skip === 0) {\n                        callBack();\n                    }\n                    else {\n                        --skip;\n                    }\n                };\n                if (intersectQry.skip && intersectQry.limit) {\n                    resultPusher = () => {\n                        skipChecker(() => {\n                            checkLimitAndPush();\n                        });\n                    };\n\n                }\n                else if (intersectQry.limit) {\n                    resultPusher = checkLimitAndPush;\n                }\n                else if (intersectQry.skip) {\n                    resultPusher = () => {\n                        skipChecker(() => {\n                            pushResult();\n                        });\n                    };\n                }\n                else {\n                    resultPusher = () => {\n                        pushResult();\n                    };\n                }\n                if (limit) {\n                    for (key in hashMap) {\n                        resultPusher(key);\n                        if (shouldStopLoop) {\n                            break;\n                        }\n                    }\n                }\n                else {\n                    for (key in hashMap) {\n                        resultPusher(key);\n                    }\n                }\n                return onFinished();\n            }\n        };\n        return fetchData();\n    }\n}","import { LogHelper, getError } from \"@worker/utils\";\nimport { ERROR_TYPE, promise } from \"@/common\";\n\nexport class DropDb {\n\n    execute(dbName: string) {\n        return promise((res, rej) => {\n            const dropDbRequest = indexedDB.deleteDatabase(dbName);\n            dropDbRequest.onblocked = () => {\n                const err = new LogHelper(ERROR_TYPE.DbBlocked);\n                return rej(\n                    getError(err)\n                );\n            };\n            dropDbRequest.onerror = (e) => {\n                return rej(\n                    getError(e)\n                )\n            };\n            dropDbRequest.onsuccess = () => {\n                res();\n            };\n        })\n    }\n}\n","import { Base } from \"@executors/base\";\nimport { ISelectQuery } from \"@/common\";\nimport { Select } from \"@executors/select\";\nimport { IDBUtil } from \"@/worker/idbutil\";\n\nexport class Union extends Base {\n\n    constructor(query: ISelectQuery[], util: IDBUtil) {\n        super();\n        this.query = query as any;\n        this.util = util;\n    }\n\n    execute() {\n        const query: ISelectQuery[] = this.query as any;\n        let index = 0;\n        const hashMap = new Map();\n        let isQueryForSameTable = true;\n        const queryLength = query.length;\n        query.every((qry, i) => {\n            if (i + 1 < queryLength && qry.from !== query[i + 1].from) {\n                isQueryForSameTable = false;\n                return false;\n            }\n            return true;\n        });\n        let getHashKey;\n        if (isQueryForSameTable) {\n            const pKey = this.primaryKey(query[0].from);\n            getHashKey = (val) => {\n                return val[pKey];\n            };\n        }\n        else {\n            getHashKey = (val) => {\n                let columnValKey = \"\";\n                for (const key in val) {\n                    columnValKey += val[key];\n                }\n                return columnValKey;\n            };\n        }\n        let select: Select;\n        const fetchData = () => {\n            if (index < query.length) {\n                select = new Select(query[index++], this.util);\n                return select.execute().then((selectResult) => {\n                    selectResult.forEach(val => {\n                        hashMap.set(getHashKey(val), val);\n                    });\n                    return fetchData();\n                })\n            }\n            else {\n                return Array.from(hashMap.values());\n            }\n        };\n        return fetchData();\n    }\n\n\n}","import { Remove } from \".\";\nimport { promise } from \"@/common\";\n\nexport const onWhereRemove = function (this: Remove, onFinish) {\n    return (e) => {\n        const cursor: IDBCursorWithValue = e.target.result;\n        if (cursor) {\n            if (this.shouldAddValue(cursor.value)) {\n                cursor.delete();\n                ++this.rowAffected;\n            }\n            cursor.continue();\n        }\n        else {\n            onFinish();\n        }\n    };\n}\n\nexport const executeWhereLogic = function (this: Remove, column, value, op) {\n    value = op ? value[op] : value;\n    const cursorRequest = this.objectStore.index(column).openCursor(this.util.keyRange(value, op));\n\n\n    return promise<void>((res, rej) => {\n        cursorRequest.onsuccess = onWhereRemove.call(this, res);\n        cursorRequest.onerror = rej\n    })\n\n}\n\n","import { BaseFetch } from \"../base_fetch\";\nimport { IRemoveQuery, QUERY_OPTION, API, IWhereQuery } from \"@/common\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { QueryHelper } from \"@executors/query_helper\";\nimport { promiseReject, isArray, getObjectFirstKey } from \"@/worker/utils\";\nimport { Select } from \"@executors/select\";\nimport { executeWhereUndefinedLogic } from \"./not_where\";\nimport { executeInLogic } from \"./in\";\nimport { executeWhereLogic } from \"./where\";\nimport { executeRegexLogic } from \"./regex\";\n\nexport class Remove extends BaseFetch {\n    isOr;\n    executeWhereUndefinedLogic;\n\n    constructor(\n        query: IRemoveQuery, util: IDBUtil\n    ) {\n        super();\n        this.query = query;\n        this.util = util;\n        this.tableName = query.from;\n    }\n\n    execute(beforeExecute: () => Promise<any>) {\n        const queryHelper = new QueryHelper(this.db);\n        const query = this.query;\n        const err = queryHelper.validate(API.Remove, query);\n        if (err) return promiseReject(\n            err\n        );\n        let pResult: Promise<void>;\n        return beforeExecute().then(_ => {\n            try {\n                this.initTransaction_();\n                if (query.where != null) {\n                    if (isArray(query.where)) {\n                        pResult = this.processWhereArrayQry();\n                    }\n                    else {\n                        pResult = this.processWhere_();\n                    }\n                }\n                else {\n                    pResult = this.executeWhereUndefinedLogic();\n                }\n\n            }\n            catch (ex) {\n                return this.onException(ex);\n            }\n            return pResult.then(() => {\n                return this.rowAffected;\n            })\n        })\n    }\n\n    private processWhereArrayQry() {\n        const selectObject = new Select(this.query, this.util);\n        selectObject.isTxQuery = this.isTxQuery;\n        return selectObject.execute().then((results) => {\n            const keyList = [];\n            const pkey = this.primaryKey(this.query.from);\n            results.forEach((item) => {\n                keyList.push(item[pkey]);\n            });\n            results = null;\n            const whereQry = { [pkey]: { [QUERY_OPTION.In]: keyList } };\n            this.query[QUERY_OPTION.Where] = whereQry;\n            return this.processWhere_();\n        })\n    }\n\n    private processWhere_() {\n        this.shouldAddValue = (value) => {\n            return this.whereChecker.check(value);\n        };\n        if ((this.query.where as IWhereQuery).or) {\n            this.processOrLogic();\n        }\n        return this.goToWhereLogic().then(() => {\n            return this.onWhereEvaluated();\n        });\n    }\n\n    private initTransaction_() {\n        if (!this.isTxQuery) {\n            this.util.createTransaction([this.query.from]);\n        }\n        this.objectStore = this.util.objectStore(this.query.from);\n    }\n\n    private onWhereEvaluated() {\n        if (this.isOr) {\n            return this.orQuerySuccess_();\n        }\n    }\n\n    private orQuerySuccess_() {\n        const orQueryFromOrInfo = (this as any)._orInfo.OrQuery\n        const key = getObjectFirstKey(orQueryFromOrInfo);\n        if (key != null) {\n            const where = {};\n            where[key] = orQueryFromOrInfo[key];\n            delete orQueryFromOrInfo[key];\n            this.query.where = where;\n            return this.goToWhereLogic().then(() => {\n                return this.onWhereEvaluated();\n            })\n        }\n        else {\n            this.isOr = true;\n        }\n    }\n\n    private processOrLogic() {\n        this.isOr = true;\n        const where = this.query.where as IWhereQuery;\n        (this as any)._orInfo = {\n            OrQuery: where.or\n        };\n\n        // free or memory\n        delete where.or;\n    }\n}\n\nRemove.prototype.executeInLogic = executeInLogic;\nRemove.prototype.executeWhereUndefinedLogic = executeWhereUndefinedLogic;\nRemove.prototype.executeWhereLogic = executeWhereLogic;\nRemove.prototype.executeRegexLogic = executeRegexLogic;","import { Remove } from \".\";\nimport { promise, promiseAll } from \"@/common\";\nimport { onWhereRemove } from \"./where\";\n\nexport const executeInLogic = function (this: Remove, column, values) {\n    const columnIndex = this.objectStore.index(column)\n    const runInLogic: (val) => Promise<void> = (value) => {\n        return promise((res, rej) => {\n            const cursorRequest = columnIndex.openCursor(this.util.keyRange(value));\n            cursorRequest.onsuccess = onWhereRemove.call(this, res);\n            cursorRequest.onerror = rej;\n        });\n    };\n\n    return promiseAll<void>(\n        values.map(function (val) {\n            return runInLogic(val);\n        })\n    );\n}\n","import { Remove } from \".\";\nimport { promise } from \"@/common\";\n\nexport const executeWhereUndefinedLogic = function (this: Remove) {\n    let cursor;\n    const cursorRequest = this.objectStore.openCursor();\n    return promise<void>((res, rej) => {\n        cursorRequest.onsuccess = (e: any) => {\n            cursor = e.target.result;\n            if (cursor) {\n                cursor.delete();\n                ++this.rowAffected;\n                (cursor as any).continue();\n            }\n            else {\n                res();\n            }\n        };\n        cursorRequest.onerror = rej;\n    })\n\n}\n","import { Remove } from \"./\";\nimport { promise } from \"@/common\";\n\nexport const executeRegexLogic = function (this: Remove, column: string, exp: RegExp) {\n    let cursor: IDBCursorWithValue;\n    const cursorRequest = this.objectStore.index(column).openCursor();\n    this.shouldAddValue = (cursor) => {\n        return exp.test(cursor.key) &&\n            this.whereChecker.check(cursor.value);\n    };\n    return promise<void>((res, rej) => {\n        cursorRequest.onsuccess = (e: any) => {\n            cursor = e.target.result;\n            if (cursor) {\n                if (this.shouldAddValue(cursor)) {\n                    cursor.delete();\n                    ++this.rowAffected;\n                }\n                cursor.continue();\n            }\n            else {\n                res();\n            }\n        };\n        cursorRequest.onerror = rej;\n    })\n\n}","import { Base } from \"@executors/base\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { MetaHelper } from \"@/worker/meta_helper\";\nimport { promise } from \"@/common\";\n\nexport class Clear extends Base {\n    constructor(tableName: string, util: IDBUtil) {\n        super();\n        this.query = tableName as any;\n        this.util = util;\n        this.tableName = tableName;\n    }\n\n    execute(beforeExecute: () => Promise<any>) {\n        const tableName: string = this.query as any;\n        if (!this.isTxQuery) {\n            this.util.createTransaction([tableName, MetaHelper.tableName]);\n        }\n        return beforeExecute().then(_ => {\n            const clearRequest: IDBRequest = this.util.objectStore(tableName).clear();\n            try {\n                return promise<void>((res, rej) => {\n                    clearRequest.onsuccess = (e) => {\n                        const currentTable = this.table(tableName);\n                        for (const columnName in currentTable.autoIncColumnValue) {\n                            currentTable.autoIncColumnValue[columnName] = 0;\n                        }\n                        MetaHelper.set(MetaHelper.dbSchema, this.util.db, this.util).then(res).catch(rej);\n                    };\n\n                    clearRequest.onerror = rej;\n                })\n            }\n            catch (ex) {\n                return this.onException(ex);\n            }\n        })\n    }\n}","import { Base } from \"@executors/base\";\nimport { ITranscationQuery, WebWorkerRequest, ERROR_TYPE, API, WebWorkerResult, promise } from \"@/common\";\nimport { IDBUtil } from \"@worker/idbutil\";\nimport { promiseReject, LogHelper, variableFromPath } from \"@worker/utils\";\nimport { Insert } from \"@executors/insert\";\nimport { Select } from \"@executors/select\";\nimport { Count } from \"@executors/count\";\nimport { Update } from \"@executors/update\";\nimport { Remove } from \"@executors/remove\";\nimport { IQueryExecutor } from \"@/worker/interfaces\";\nimport { MetaHelper } from \"@/worker/meta_helper\";\n\nexport class Transaction extends Base {\n    results = {} as any;\n    reqQueue: WebWorkerRequest[] = [];\n    isQueryExecuting = false;\n\n    isTxStarted_ = false;\n\n    onSuccess: (result: any) => void;\n    onError: (err: LogHelper) => void;\n\n    beforeExecute: () => Promise<void>;\n\n    constructor(qry: ITranscationQuery, util: IDBUtil) {\n        super();\n        this.query = qry as any;\n        this.util = util;\n    }\n\n    execute(cb: () => Promise<void>) {\n        this.beforeExecute = cb;\n        const err = this.validate();\n        if (err) return promiseReject(\n            err\n        );\n        this.startExecution_()\n\n        return promise<void>((res, rej) => {\n            this.onSuccess = res;\n            this.onError = rej;\n        }).then(result => {\n            this.beforeExecute = null;\n            this.log(`transaction finished`);\n            return result;\n        })\n    }\n\n    validate() {\n        const query: ITranscationQuery = this.query as any;\n        const notExistingTable = this.notExistingTable_(query.tables);\n        if (notExistingTable) {\n            return new LogHelper(ERROR_TYPE.TableNotExist, { tableName: notExistingTable });\n        }\n        const methodName = query.method;\n        let txLogic = variableFromPath(methodName);\n        if (!txLogic) {\n            return new LogHelper(ERROR_TYPE.MethodNotExist, methodName);\n        }\n    }\n\n    private startExecution_() {\n        const query: ITranscationQuery = this.query as any;\n        const createPusher = (api: any) => {\n            return (qry) => {\n                return this.pushReq_({\n                    name: api,\n                    query: qry\n                } as WebWorkerRequest);\n            }\n        };\n        const setResult = (key: string, value) => {\n            this.results[key] = value;\n        };\n        const getResult = (key: string) => {\n            return this.results[key];\n        };\n        const abort = (msg: string) => {\n            this.abortTx_(msg);\n        };\n\n        const start = () => {\n            this.startTx_();\n        };\n        const methodName = query.method\n        let txLogic = variableFromPath(methodName);\n\n        this.log(`transaction query started`);\n\n        return txLogic.call(\n            this,\n            {\n                data: query.data,\n                insert: createPusher(API.Insert),\n                select: createPusher(API.Select),\n                update: createPusher(API.Update),\n                remove: createPusher(API.Remove),\n                count: createPusher(API.Count),\n                setResult: setResult,\n                getResult: getResult, abort: abort,\n                start: start\n            }\n        );\n    }\n\n    log(message) {\n        this.util.logger.log(message);\n    }\n\n    private startTx_() {\n        try {\n            this.isTxStarted_ = true;\n            let tableNames = (this.query as any).tables as string[];\n            tableNames = tableNames.concat(MetaHelper.tableName)\n            this.util.createTransaction(tableNames).then(_ => {\n                this.onSuccess(this.results);\n            }).catch(err => {\n                this.onError(err);\n            })\n            return this.processExecutionOfQry_();\n        }\n        catch (ex) {\n            this.onError(this.onException(ex) as any);\n        }\n    }\n\n\n\n\n\n    private onReqFinished_(result) {\n        const finisehdRequest = this.reqQueue.shift();\n\n        this.log(`finished request : ${finisehdRequest.name} `);\n\n        if (finisehdRequest) {\n            if (result.error) {\n                this.abortTx_(\"automatic abort of transaction due to error occured\");\n                this.log(`transaction aborted due to error occured`);\n                this.onError(result.error);\n            }\n            else {\n                this.isQueryExecuting = false;\n                if (finisehdRequest.onSuccess) {\n                    finisehdRequest.onSuccess(result);\n                }\n                this.processExecutionOfQry_();\n            }\n        }\n    }\n\n    private abortTx_(msg: string) {\n        this.reqQueue = [];\n        this.util.abortTransaction();\n        this.log(`transaction aborted. Msg : ${msg}`);\n\n    }\n\n    private executeRequest_(request: WebWorkerRequest) {\n        this.isQueryExecuting = true;\n        let requestObj: IQueryExecutor;\n        this.log(`executing request : ${request.name} `);\n        const onReqFinished = this.onReqFinished_.bind(this);\n        const query = request.query;\n\n        const callAPI = (api: typeof Select) => {\n            requestObj = new api(\n                query, this.util\n            );\n        };\n\n        switch (request.name) {\n            case API.Select:\n                callAPI(Select);\n                break;\n            case API.Insert:\n                callAPI(Insert as any);\n                break;\n            case API.Update:\n                callAPI(Update as any);\n                break;\n            case API.Remove:\n                callAPI(Remove as any);\n                break;\n            case API.Count:\n                callAPI(Count as any);\n                break;\n        }\n        requestObj.isTxQuery = true;\n        requestObj.execute(this.beforeExecute).then(onReqFinished).catch(err => {\n            const result = {\n                error: err\n            } as WebWorkerResult;\n            onReqFinished(result);\n        })\n    }\n\n    private pushReq_(request: WebWorkerRequest) {\n        const promiseObj = promise((resolve, reject) => {\n            request.onSuccess = (result) => {\n                resolve(result);\n            };\n            request.onError = (error) => {\n                reject(error);\n            };\n        });\n        this.reqQueue.push(request);\n        if (this.isTxStarted_ === true) {\n            this.processExecutionOfQry_();\n        }\n\n        this.log(`request pushed : ${request.name}`);\n        return promiseObj;\n    }\n\n    private processExecutionOfQry_() {\n        if (this.isQueryExecuting === false) {\n            if (this.reqQueue.length > 0) {\n                this.executeRequest_(this.reqQueue[0]);\n            }\n        }\n    }\n\n    private notExistingTable_(tables: string[]) {\n        let invalidTable: string = null;\n        tables.every(tableName => {\n            const table = this.table(tableName);\n            if (table == null) {\n                invalidTable = tableName;\n                return false;\n            }\n            return true;\n        });\n        return invalidTable;\n    }\n}","import { DbMeta } from \"@worker/model\";\nimport { IDataBase, ITable } from \"@/common\";\n\nexport const userDbSchema = (db: DbMeta) => {\n    if (db == null) {\n        throw new Error(`userDbSchema db is null`);\n    }\n    const database = {\n        name: db.name,\n        version: db.version,\n        tables: []\n    } as IDataBase;\n    db.tables.forEach(table => {\n        const tableAsObj = {\n            name: table.name,\n            columns: {}\n        } as ITable;\n        table.columns.forEach(column => {\n            tableAsObj.columns[column.name] = column;\n        });\n        database.tables.push(tableAsObj);\n    })\n    return database;\n}","import { WebWorkerRequest, promiseResolve, API, IDataBase, WebWorkerResult, promise, ERROR_TYPE, IDbInfo, InitDbResult } from \"@/common\";\nimport { DbMeta } from \"./model\";\nimport { IDBUtil } from \"./idbutil\";\nimport { Insert } from \"@executors/insert\";\nimport { IS_WORKER, IS_IDB_SUPPORTED } from \"./constants\";\nimport { MetaHelper } from \"./meta_helper\";\nimport { Select } from \"@executors/select\";\nimport { Count } from \"@executors/count\";\nimport { Update } from \"@executors/update\";\nimport { Intersect } from \"./intersect\";\nimport { DropDb } from \"@executors/drop_db\";\nimport { Union } from \"./union\";\nimport { Remove } from \"@executors/remove\";\nimport { Clear } from \"@executors/clear\";\nimport { Transaction } from \"@executors/transaction\";\nimport { LogHelper, getError, promiseReject, variableFromPath, userDbSchema, getLength } from \"@worker/utils\";\n\nexport class QueryManager {\n    util: IDBUtil;\n\n    get db() {\n        return this.util.db;\n    }\n\n    middlewares: string[] = [];\n\n    private onQryFinished;\n\n    protected get logger() {\n        return this.util.logger;\n    }\n\n    constructor(fn?: (result: any) => void) {\n        this.util = new IDBUtil();\n        this.onQryFinished = IS_WORKER ? (result) => {\n            self.postMessage(result);\n        } : fn;\n    }\n\n    private executeMiddleware_(request: WebWorkerRequest) {\n        const lastIndex = (getLength(this.middlewares) as any) - 1;\n        if (lastIndex < 0) {\n            return promiseResolve();\n        }\n        const middlewareContext = {};\n        const db = this.db;\n        Object.defineProperty(middlewareContext, 'database', {\n            get() {\n                return userDbSchema(db);\n            }\n        });\n        return promise<void>((res) => {\n            let index = 0;\n            const callNextMiddleware = () => {\n                if (index <= lastIndex) {\n                    let promiseResult = variableFromPath(this.middlewares[index++])(request, middlewareContext);\n                    if (!promiseResult || !promiseResult.then) {\n                        promiseResult = Promise.resolve(promiseResult);\n                    }\n                    promiseResult.then(_ => {\n                        callNextMiddleware();\n                    });\n                }\n                else {\n                    res();\n                }\n            };\n            callNextMiddleware();\n        });\n    }\n\n    executeQuery(request: WebWorkerRequest, cb: () => Promise<any>) {\n        let queryResult: Promise<any>;\n        const query = request.query;\n        const ctx = this;\n        const idbutil = ctx.util;\n        const callAPI = (api: typeof Select, beforeExecute?: () => Promise<any>) => {\n            queryResult = new api(query, idbutil).\n                execute(beforeExecute);\n        };\n        switch (request.name) {\n            case API.OpenDb:\n                cb();\n                queryResult = ctx.openDb(query);\n                break;\n            case API.InitDb:\n                cb();\n                queryResult = ctx.initDb(query);\n                break;\n            case API.CloseDb:\n                cb();\n                queryResult = ctx.closeDb();\n                break;\n            case API.Insert:\n                callAPI(Insert as any, cb);\n                break;\n            case API.Select:\n                callAPI(Select as any, cb);\n                break;\n            case API.Count:\n                callAPI(Count as any, cb);\n                break;\n            case API.Update:\n                callAPI(Update as any, cb);\n                break;\n            case API.Intersect:\n                cb();\n                callAPI(Intersect as any);\n                break;\n            case API.DropDb:\n                cb();\n                queryResult = ctx.dropDb();\n                break;\n            case API.Terminate:\n                cb();\n                queryResult = ctx.terminate();\n                break;\n            case API.Union:\n                cb();\n                callAPI(Union as any);\n                break;\n            case API.Remove:\n                callAPI(Remove as any, cb);\n                break;\n            case API.Clear:\n                callAPI(Clear as any, cb);\n                break;\n            case API.Transaction:\n                callAPI(Transaction as any, cb);\n                break;\n            case API.Get:\n                cb();\n                queryResult = MetaHelper.get(query as string, idbutil);\n                break;\n            case API.Set:\n                cb();\n                queryResult = MetaHelper.set(query.key, query.value, idbutil);\n                break;\n            case API.ImportScripts:\n                cb();\n                queryResult = ctx.importScripts_(request);\n                break;\n            case API.ChangeLogStatus:\n                cb();\n                ctx.logger.status = query;\n                queryResult = Promise.resolve();\n                break;\n            case API.Middleware:\n                cb();\n                const value = variableFromPath(query);\n                if (!value) {\n                    return promiseReject(\n                        new LogHelper(ERROR_TYPE.InvalidMiddleware, query)\n                    );\n                }\n                ctx.middlewares.push(query);\n                return promiseResolve();\n            default:\n                if (process.env.NODE_ENV !== 'production') {\n                    console.error('The Api:-' + request.name + ' does not support.');\n                }\n                queryResult = promiseResolve();\n        }\n        ctx.logger.log(`Executing query ${request.name} in web worker`);\n        return queryResult;\n    }\n\n    private callMiddleware_(middlewares: any[], result?) {\n        return promise<any>((res) => {\n            let index = 0;\n            const lastIndex = (getLength(middlewares) as any) - 1;\n            const callNextMiddleware = () => {\n                if (index <= lastIndex) {\n                    let promiseResult = middlewares[index++](result);\n                    if (!(promiseResult instanceof Promise)) {\n                        promiseResult = promiseResolve(promiseResult);\n                    }\n                    promiseResult.then(modifiedResult => {\n                        result = modifiedResult;\n                        callNextMiddleware();\n                    });\n                }\n                else {\n                    res(result);\n                }\n            };\n            callNextMiddleware();\n        });\n    }\n\n    run(request: WebWorkerRequest) {\n        let onResultCallback = [];\n        const beforeExecuteCallback = [];\n        request.onResult = (cb) => {\n            onResultCallback.push((result) => {\n                return cb(result);\n            });\n        };\n        request.beforeExecute = (cb) => {\n            beforeExecuteCallback.push((result) => {\n                return cb(result);\n            });\n        };\n        this.executeMiddleware_(request).then(_ => {\n            return this.executeQuery(request, () => {\n                return this.callMiddleware_(beforeExecuteCallback);\n            }).then((result) => {\n                return this.callMiddleware_(onResultCallback, result).then(modifiedResult => {\n                    this.returnResult_({\n                        result: modifiedResult\n                    });\n                });\n            });\n        }).catch(ex => {\n            onResultCallback = [];\n            const err = getError(ex);\n            const result = {\n                error: err\n            } as WebWorkerResult;\n            this.returnResult_(result);\n        });\n    }\n\n    private importScripts_(request: WebWorkerRequest) {\n        return promise<void>((res, rej) => {\n            try {\n                importScripts(...request.query);\n                res();\n            } catch (e) {\n                const err = new LogHelper(ERROR_TYPE.ImportScriptsFailed, e.message);\n                rej(err);\n            }\n        });\n    }\n\n    private returnResult_(result: WebWorkerResult) {\n        this.logger.log(`Query finished inside web worker`);\n        if (this.util) {\n            this.util.emptyTx();\n        }\n        this.onQryFinished(result);\n    }\n\n    private dropDb() {\n        const dbName = this.db.name;\n        return this.terminate().then(() => {\n            return new DropDb().execute(dbName);\n        });\n    }\n\n    closeDb() {\n        return this.util.close();\n    }\n\n    terminate() {\n        return this.closeDb().then(() => {\n            this.util.db = null;\n        });\n    }\n\n    openDb(query: IDbInfo) {\n        return this.closeDb().then(_ => {\n            let pResult: Promise<InitDbResult>;\n            if (this.db && query.name === this.db.name) {\n                pResult = this.initDb();\n            }\n            else {\n                pResult = this.initDb({\n                    name: query.name,\n                    tables: [\n                    ],\n                    version: query.version\n                });\n            }\n            return pResult.then(() => {\n                return this.db;\n            });\n        });\n    }\n\n    initDb(dataBase?: IDataBase) {\n        if (!IS_IDB_SUPPORTED) {\n            return promiseReject(\n                new LogHelper(ERROR_TYPE.IndexedDbNotSupported)\n            );\n        }\n\n        const dbMeta = dataBase ? new DbMeta(dataBase) : this.db;\n        if (dbMeta == null) {\n            throw new Error(`dbMeta is null`);\n        }\n        this.util = new IDBUtil();\n\n        return this.util.initDb(dbMeta).then(dbInfo => {\n            return MetaHelper.get(\n                MetaHelper.dbSchema,\n                this.util\n            ).then((dbFromCache: DbMeta) => {\n                if (dbInfo.isCreated) {\n                    if (dbFromCache) {\n                        dbFromCache.tables.forEach((tableFromCache) => {\n                            const targetTable = dbMeta.tables.find(q => q.name === tableFromCache.name);\n                            if (targetTable) {\n                                for (const key in tableFromCache.autoIncColumnValue) {\n                                    const savedAutoIncrementValue = tableFromCache.autoIncColumnValue[key];\n                                    if (savedAutoIncrementValue) {\n                                        targetTable.autoIncColumnValue[key] = savedAutoIncrementValue;\n                                    }\n                                }\n                            }\n                        });\n                    }\n                    this.util.db = dbMeta;\n                    dbInfo.database = userDbSchema(this.db);\n                    return MetaHelper.set(\n                        MetaHelper.dbSchema, dbMeta,\n                        this.util\n                    ).then(() => {\n                        return dbInfo;\n                    });\n                }\n                else {\n                    return MetaHelper.get(\n                        MetaHelper.dbSchema,\n                        this.util\n                    ).then((value: any) => {\n                        this.util.db = value;\n                        dbInfo.database = userDbSchema(this.db);\n                        return dbInfo;\n                    });\n                }\n            });\n        });\n    }\n}\n","import { QueryManager } from \"@/worker/query_manager\";\nimport { IS_WORKER } from \"./constants\";\nexport * from \"./query_manager\";\n\nif (IS_WORKER) {\n    const manager = new QueryManager();\n    (self as any).onmessage = function (e) {\n        manager.run(e.data);\n    };\n}\n\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","WORKER_STATUS","DATA_TYPE","API","EVENT","QUERY_OPTION","IDB_MODE","OCCURENCE","CONNECTION_STATUS","promiseResolve","Promise","resolve","promise","cb","ERROR_TYPE","table","columns","autoIncColumnValue","this","setColumn","name","alter","tableColumns","columnName","column","autoIncrement","primaryKey","enableSearch","existingColumnIndex","indexOf","q","push","existingColumn","assign","autoIncrementKey","tableName","set","util","tx","createTransaction","MetaHelper","store","objectStore","res","rej","req","put","onsuccess","onerror","keyRange","result","remove","delete","dbSchema","db","version","tables","map","TableMeta","forObj","type","info","info_","message","getMsg_","log","msg","status","console","throw","logError","error","errMsg","errorHandler","getInfo","errorType","method","logger","LogHelper","emptyTx","oncomplete","onabort","createTransactionIfNotExist","mode","ReadWrite","con","transaction","op","Between","IDBKeyRange","bound","low","high","GreaterThan","lowerBound","GreaterThanEqualTo","LessThan","upperBound","LessThanEqualTo","only","abortTransaction","abort","close","setTimeout","initDb","oldVersion","isDbCreated","dbVersion","dbOpenRequest","indexedDB","open","onversionchange","e","target","isCreated","newVersion","onupgradeneeded","upgradeConnection","storeNames","objectStoreNames","addColumn","indexNames","contains","options","unique","multiEntry","keyPath","createIndex","deleteColumn","index","findIndex","splice","deleteIndex","forEach","option","createObjectStore","i","alterQuery","add","drop","modify","shouldDelete","targetColumn","find","newColumn","storeName","item","qry","deleteObjectStore","length","promiseAll","promises","all","promiseReject","reject","getError","rowAffected","isTxQuery","results","query","from","meta","getColumnInfo","onException","ex","getErrorFromException","getDataType","Null","Array","isArray","Date","DateTime","isNull","isNaN","autoIncValues","autoIncrementValue","checkAndModifyValues","err","values","ignoreIndexes","every","checkAndModifyValue","ignore","checkAndModifyColumnValue_","checkNotNullAndDataType_","notNull","ColumnName","dataType","columnValue","Number","undefined","default","validation","details","check","setValue","tblName","checkByColumn_","checkFurther","allowedOp","validate","api","Select","Remove","Count","checkSelect","Insert","checkInsertQuery","Update","checkUpdate","getTable_","isInsertQryValid","into","SchemaChecker","in","where","checkForNullInWhere_","addGreatAndLessToNotOp_","whereQuery","containsNot","keys","NotEqualTo","addToSingleQry","Or","queryKeys","qryKeys","validResult","skipDataCheck","ValuesChecker","valuesAffected_","execute","beforeInsert","QueryHelper","then","_","insertData_","return","catch","onInsertData","addMethod","idbMethod","upsert","addResult","Base","IS_WORKER","self","alert","ServiceWorkerGlobalScope","IS_IDB_SUPPORTED","mozIndexedDB","webkitIndexedDB","msIndexedDB","IDBTransaction","webkitIDBTransaction","msIDBTransaction","webkitIDBKeyRange","msIDBKeyRange","setCrossBrowserIndexedDb","getKeys","getLength","getObjectFirstKey","setCaseAndValue","caseQuery","caseQuery_","setCaseAndColumn","columnName_","caseColumnQuery_","length_","evaluate","checkCase_","lastThen","cond","queryOption","Equal","getCursorOnSuccess","simpleFn","limitFn","skipFn","skipAndLimitFn","limitAtEnd","skipAtEnd","skipRecord","limitRecord","executeSkipAndLimitForWhere_","onFinish","recordSkipped","cursor","shouldAddValue","pushResult","continue","advance","executeSkipForWhere_","executeLimitForWhere_","executeSimpleForWhere_","executeSkipAndLimit","onFinished","executeSkip","executeSimple","executeLimit","removeSpace","replace","getOrderColumnInfo","orderColumn","join","splittedByDot","split","joinOrderColumn","valueFromFirstColumn","isOrder","compareStringInDesc_","a","b","localeCompare","compareStringinAsc_","compareDefaultInDesc_","String","compareDefaultinAsc_","compareNumberInDesc_","compareNumberinAsc_","compareDateInDesc_","getTime","compareDateInAsc_","getValueComparer_","order","orderBy_","getOrderType_","by","thenEvaluator","getValInAscDesc","stringComparer","numberComparer","value1","value2","column1","column2","sortMethod","sort","columnInfo","case","toLowerCase","getRegexFromLikeExpression","likeExpression","filterValue","occurence","filterValues","Any","Last","First","RegExp","clone","copy","compare","compareValue","symbol","type1","checkFlag","props","last","pop","reduce","prev","curr","rowValue","whereColumnValue","isArrayColumnValue","isArrayWhereColumnValue","executeCompare","executor","In","checkIn","Like","checkLike_","Regex","checkRegex","checkComparisionOp_","storedValue","test","goToWhereLogic","firstColumn","whereChecker","WhereChecker","executeWhereLogic","regexVal","executeRegexLogic","executeInLogic","Aggregate","skipOrPush","select","joinQueryStack_","currentQueryStackIndex_","tablesFetched","getTable","executeSelect","tablesToFetch","joinQueryStack","jointblInfo","getJoinTableInfo_","on","with","table1","table2","checkJoinQuery_","joinTableInfo","whereQryParam","whereQryAfterJoin","filter","isWhereEmpty","filteredOr","whereQryOr","orColumn","whereQueryModified","removeJoinColumnResult","joinQuery","flatten","startExecutingJoinLogic_","onJoinQueryFinished_","selectApi","data","setLimitAndSkipEvaluationAtEnd_","processOrderBy","jointables","secondtableData","valueMatchedFromSecondTable","joinerComparer","defaultValueSetter","columnDefaultValue","joinType","output","table1Index","table2Index","asQuery","as","mapWithAlias","asValue","val","whereQry","whereCheker","col","valueFromSecondTable","valueFromFirstTable","joinOn","splittedjoinOn","splittedjoinOnbydotFirst","splittedjoinOnbydotSecond","tableSchemaOf1stTable","tableSchemaOf2ndTable","columnFound","whereJoin","openCursor","cursorRequest","callOnSuccess","includes","sorted","isSubQuery","ThenEvaluator","returnResult_","Map","concat","processGroupDistinctAggr","skip","slice","limit","setPushResult","isArrayQry","orderQuery","groupBy","beforeExecute","initTransaction_","processWhereArrayQry","processWhere_","executeWhereUndefinedLogic","executeJoinQuery","bind","operation","pKey","isFirstWhere","onSuccess","andResults","And","keyValue","removeDuplicates","processFirstQry","executeWhere","whereQueryToProcess","shift","whereQueryOr","MemoryObjectStore","ReadOnly","cursorValue","that","proxy","Proxy","p","receiver","or","processOrLogic_","onWhereEvaluated","isOr","orQuerySuccess_","orQueryFinish_","orInfo","orQuery","BaseFetch","idbSorting","orderType","dir","exp","datas","lookupObject","len","Join","distinct","aggregate","executeAggregateGroupBy","processGroupBy","processAggregateQry","orderQueryType","prevOrderQueryBy","currentOrderQuery","currentorderQueryBy","orderColumnDetail","columnToAggregate","datasLength","getCount","getMax","getMin","Infinity","getSum","getAvg","aggregateQry","aggregateColumn","aggregateValType","aggregateCalculator","objKey","grpQry","lookUpObj","calculateAggregate","getList","sumOfColumn","Max","Min","Sum","Avg","List","avgQuery","avg","sumForAvg","countForAvg","count","sum","isCountTypeString","isSumTypeString","avgColumn","groupByDataType","groupByColumn","onWhereCount","resultCount","queryHelper","getDataFromSelect","selectInstance","countRequest","isWhereKeysLengthOne","columnStore","variableFromPath","path","updateValue","mapSet","columnSetValue","initTransaction","executeComplexLogic_","selectObject","ignoreCase","inQuery","cursorUpdateRequest","update","cursorOpenRequest","intersectQry","getHashKey","hashMap","hashMapTemp","isQueryForSameTable","queries","queryLength","columnValKey","fetchData","selectResult","resultPusher","callBack","dbName","dropDbRequest","deleteDatabase","onblocked","onWhereRemove","pResult","keyList","pkey","Where","processOrLogic","orQueryFromOrInfo","_orInfo","OrQuery","columnIndex","clearRequest","clear","currentTable","reqQueue","isQueryExecuting","isTxStarted_","startExecution_","onError","notExistingTable","notExistingTable_","methodName","createPusher","pushReq_","txLogic","insert","setResult","getResult","abortTx_","start","startTx_","tableNames","processExecutionOfQry_","onReqFinished_","finisehdRequest","executeRequest_","request","requestObj","onReqFinished","callAPI","promiseObj","invalidTable","userDbSchema","Error","database","tableAsObj","fn","middlewares","IDBUtil","onQryFinished","postMessage","executeMiddleware_","lastIndex","middlewareContext","callNextMiddleware","promiseResult","executeQuery","queryResult","ctx","idbutil","OpenDb","openDb","InitDb","CloseDb","closeDb","Intersect","DropDb","dropDb","Terminate","terminate","Union","Clear","Transaction","Get","Set","ImportScripts","importScripts_","ChangeLogStatus","Middleware","callMiddleware_","modifiedResult","run","onResultCallback","beforeExecuteCallback","onResult","importScripts","dataBase","dbMeta","DbMeta","dbInfo","dbFromCache","tableFromCache","targetTable","savedAutoIncrementValue","QueryManager","onmessage"],"sourceRoot":""}